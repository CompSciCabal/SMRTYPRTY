(require-extension sicp)
(require-extension numbers)

;; SICP Chapter 1, Section 1.2, Procedures and the Processes they
;; Generate

;; Exercise 1.9: Each of the following two procedures defines a method
;; for adding two positive integers in terms of the procedures inc,
;; which increments its argument by 1, and dec, which decrements its
;; argument by 1.

;; (define (+ a b)
;;   (if (= a 0)
;;       b
;;       (inc (+ (dec a) b))))

;; (define (+ a b)
;;   (if (= a 0)
;;       b
;;       (+ (dec a) (inc b))))

;; Using the substitution model, illustrate the process generated by
;; each procedure in evaluating (+ 4 5). Are these processes iterative
;; or recursive?

;; Answer for the first fn:

;; (+ 4 5)
;; (inc (+ 3 5))
;; (inc (inc (+ 2 5)))
;; (inc (inc (inc (+ 1 5))))
;; (inc (inc (inc (inc 5))))
;; (inc (inc (inc 6)))
;; (inc (inc 7))
;; (inc 8)
;; 9

;; Answer for the second fn:

;; (+ 4 5)
;; (+ 3 6)
;; (+ 2 7)
;; (+ 1 8)
;; (+ 0 9)
;; 9

;; The first process is recursive, the second is iterative.


;; Exercise 1.10: The following procedure computes a mathematical
;; function called Ackermann’s function.

(define (A m n)
  (cond ((= n 0) 0)
        ((= m 0) (* 2 n))
        ((= n 1) 2)
        (else (A (- m 1)
                 (A m (- n 1))))))

;; what are the values of the following expressions?

;; (A 1 10) => 1024
;; (A 2 4)  => 65536
;; (A 3 3)  => 65536

;; Consider the following procedures, where A is the procedure defined above:

(define (f n) (A 0 n))

;; (A 0 5)
;; (* 2 5)
;; 10

(define (g n) (A 1 n))

;; (A 1 5)
;; (A 0 (A 1 4))
;; (A 0 (A 0 (A 1 3)))
;; (A 0 (A 0 (A 0 (A 1 2))))
;; (A 0 (A 0 (A 0 (A 0 (A 1 1)))))
;; (A 0 (A 0 (A 0 (A 0 2))))
;; (A 0 (A 0 (A 0 4)))
;; (A 0 (A 0 8))
;; (A 0 16)
;; 32

(define (h n) (A 2 n))

;; (A 2 2)
;; (A 1 (A 2 1))
;; (A 1 2)
;; (A 0 (A 1 1))
;; (A 0 2)
;; 4

;; (A 2 4)
;; (A 1 (A 2 3))
;; (A 1 (A 1 (A 2 2)))
;; (A 1 (A 1 (A 1 (A 2 1))))
;; (A 1 (A 1 (A 1 2)))
;; (A 1 (A 1 (A 0 (A 1 1))))
;; (A 1 (A 1 (A 0 2)))
;; (A 1 (A 1 4))
;; (A 1 (A 0 (A 1 3)))
;; (A 1 (A 0 (A 0 (A 1 2))))
;; (A 1 (A 0 (A 0 (A 0 (A 1 1)))))
;; (A 1 (A 0 (A 0 (A 0 2))))
;; (A 1 (A 0 (A 0 4)))
;; (A 1 (A 0 8))
;; (A 1 16)
;; (A 0 (A 1 15))
;; (A 0 (A 0 (A 1 14)))
;; (A 0 (A 0 (A 0 (A 1 13))))
;; (A 0 (A 0 (A 0 (A 0 (A 1 12)))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 11))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 10)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 9))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 8)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 7))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 6)))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 32)))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 64))))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 128)))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 256))))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 512)))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 1024))))))
;; (A 0 (A 0 (A 0 (A 0 (A 0 2048)))))
;; (A 0 (A 0 (A 0 (A 0 4096))))
;; (A 0 (A 0 (A 0 8192)))
;; (A 0 (A 0 16384))
;; (A 0 32768)
;; 65536

(define (k n) (* 5 n n))

;; Give concise mathematical definitions for the functions computed by
;; the procedures f, g, and h for positive integer values of nn. For
;; example, (k n) computes 5n^2

;; Answer:

;; (f n) computes 2n
;; (g n) computes 2^n

;; (h n) computes n^h(n-1)

;; Mind blown. I can't quite grasp it, and I also note that the
;; definition of this fn on wikipedia is slightly different, though
;; only in the base cases.

;; Kevin found a great discussion on Wolfram Alpha:
;;   http://mathworld.wolfram.com/AckermannFunction.html

;; Things I found useful to have around while working:

(define (range x)
  (define (iter x y)
    (if (= x 0)
        y
        (iter (- x 1) (cons x y))))
  (iter x '()))

(define (repeat x y)
  (define (iter x z)
    (if (= x 0)
        z
        (iter (- x 1) (cons y z))))
  (iter x '()))

(define (pow x y)
  (apply * (repeat y x)))

;; Tree Recursion - fibonacci

(define (fib-recursive n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib-recursive (- n 1))
                 (fib-recursive (- n 2))))))

;; Iterative version

(define (fib-iterative n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))

;; Coin counting

(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0)
             (= kinds-of-coins 0))
         0)
        (else
         (+ (cc amount (- kinds-of-coins 1))
            (cc (- amount (first-denomination
                           kinds-of-coins))
                kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

;; From the book:

;; Count-change generates a tree-recursive process with redundancies
;; similar to those in our first implementation of fib. (It will take
;; quite a while for that 292 to be computed.) On the other hand, it
;; is not obvious how to design a better algorithm for computing the
;; result, and we leave this problem as a challenge.

;; LOL @ "take quite a while". Maybe in 1985.

;; Exercise 1.11

;; A function f is defined by the rule that f(n)=n if n<3 and
;; f(n)=f(n−1)+2f(n−2)+3f(n−3) if n≥3. Write a procedure that computes
;; f by means of a recursive process. Write a procedure that computes
;; f by means of an iterative process.

(define (f-recursive n)
  (if (< n 3)
      n
      (+ (f-recursive (- n 1))
         (* 2 (f-recursive (- n 2)))
         (* 3 (f-recursive (- n 3))))))

(define (f-iterative n)
  (define (iter c x y z)
    (if (= c n)
        x
        (iter (+ c 1) (+ x (* 2 y) (* 3 z)) x y)))
  (if (< n 3)
      n
      (iter 2 2 1 0)))
