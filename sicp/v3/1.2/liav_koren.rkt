; Section 1.2
; ===========

#|
Exercise 1.9
============

Each of the following two procedures defines a method for adding two positive
integers in terms of the procedures inc, which increments its argument by 1,
and dec, which decrements its argument by 1.

(define (+ a b)
  (if (= a 0) 
      b 
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0) 
      b 
      (+ (dec a) (inc b))))

Using the substitution model, illustrate the process generated by each procedure in
evaluating (+ 3 2). Are these processes iterative or recursive?

Answer
======
NB: I've cheated a bit and decreased the arguments from (+ 4 5) to (+ 2  3). I'm a busy
person.

First version
-------------
Generates a process that looks like this:

(inc (+ (dec 3) 2)
(inc (+ (dec (dec 3)) 2)
(inc (+ (dec (dec (dec 3))) 2)

This is a recursive procedure because it is storing the number of times to apply '+' to
2 in the stack.

Second version
--------------
(+ (dec 3) (inc 2))
(+ (dec (dec 3)) (inc (inc 2))
(+ (dec (dec (dec 3))) (inc (inc (inc 2)))

Even though the second version has nested dec and inc calls, this is an iterative process,
because there is no information about the state of the computation stored in the stack. 
|#


#|

Exercise 1.10
=============
The following procedure computes a mathematical function called Ackermann’s function.
|#

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

; What are the values of the following expressions?


(display "(A 1 10):")
(A 1 10)
(display "(A 2 4):")
(A 2 4)
(display "(A 3 3):")
(A 3 3)


#|
; Consider the following procedures, where A is the procedure defined above:

Give concise mathematical definitions for the functions computed by the procedures f, g,
and h for positive integer values of n . For example, (k n) computes 5 n 2.|#


(define (f n) (A 0 n))
(f 0)
(f 1)
(f 2)
(f 3)
(f 4)
(f 5)
(f 10)
(f 6.6)
(f -5.5)
; 2 * n
(define (g n) (A 1 n))
(g 0)
(g 1)
(g 2)
(g 3)
(g 4)
(g 5)
(g 10)
; (g 6.6) does not terminate
; (g -5) does note terminate
; 2 ^ n

(define (h n) (A 2 n))
(h 1)
(h 2)
(h 3)
(h 4)
; negative and floats do not terminate
; 2^2^2...n times, (Knuth up arrow).

#|
Exercise 1.11
=============

A function f is defined by the rule that

f ( n ) = n if n < 3 and
f ( n ) = f (n - 1) + 2f (n - 2) + 3f(n - 3) if n ≥ 3.

Write a procedure that computes f by means of a recursive process.
Write a procedure that computes f by means of an iterative process. 
|#

(define (f-recurse n)
  (if (< n 3)
      n
      (+ (f-recurse (- n 1)) (* 2 (f-recurse (- n 2))) (* 3 (f-recurse (- n 3))))))

; f(0) = 0
; f(1) = 1
; f(2) = 2
; f(3) = f(2) + 2f(1) + 3f(0) = 2 + 2 + 0 = 4
; f(4) = f(3) + 2f(2) + 3f(1) = 4 + 2 * 2 + 3 * 1 = 11
; f(5) = f(4) + 2f(3) + 3f(2) = 11 + 2*4 + 3*2 = 25
; f(6) = f(5) + 2f(4) + 3f(3) = 22 + 20 + 9 = 59  <-- 

; f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3)

#|

This was hard to figure out, and I find the text's discussion of the fib transform a <- a + b; b <- a
to be actively misleading. However once I drew the following table, the solution was clear:

acc  a  b  c  n
---------------
4    2  1  0  3
11   4  2  1  4
25  11  4  2  5
59  25 11  4  6
.
.
.

|#

(define (f-iter n)
  (define (inner a b c count)
    (if (= 0 count)
        (+ a (* 2 b) (* 3 c))
        (inner (+ a (* 2 b) (* 3 c)) a b (- count 1))
        ))
  (if (< n 3)
      n
      (inner 2 1 0 (- n 3))))


