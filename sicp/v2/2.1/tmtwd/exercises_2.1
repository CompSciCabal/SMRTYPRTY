#lang racket

;; provided from SICP
(define (gcd m n)
(cond ((< m n) (gcd n m))
((= n 0) m)
(else (gcd n (remainder m n)))))
(define (make-rat n d)
(let ((g (gcd n d)))
(cons (/ n g) (/ d g))))
(define (numer r)
(car r))
(define (denom r)
(cdr r))
(define (add-rat x y)
(make-rat (+ (* (numer x) (denom y))
(* (numer y) (denom x)))
(* (denom x) (denom y))))
(define (sub-rat x y)
(make-rat (- (* (numer x) (denom y))
(* (numer y) (denom x)))
(* (denom x) (denom y))))
(define (mul-rat x y)
(make-rat (* (numer x) (numer y))
(* (denom x) (denom y))))
(define (div-rat x y)
(make-rat (* (numer x) (denom y))
(* (denom x) (numer y))))
(define (eql-rat? x y)
(= (* (numer x) (denom y))
(* (denom x) (numer y))))
(define (print-rat r)
(fprintf (current-output-port)
"~a/~a~%"
(numer r)
(denom r)))

;;Exercise 2.2

(define (avg x y)
  (/ (+ x y)
     2))

(define (print-point p)
  (newline)
  (display "(")
  (display (x-point p))
  (display ",")
  (display (y-point p))
  (display ")"))

;(define (make-segment x1 y1 x2 y2)
;  (list (list x1 y1) (list x2 y2)))

(define (make-point x1 y1)
  (cons x1 y1))

(define (x-point p)
  (car p))

(define (y-point p)
  (cdr p))

(define (make-segment p1 p2)
  (cons p1 p2))

;;2.4
(define (my_cons x y)
  (lambda (m) (m x y)))
(define (my_car z)
  (z (lambda (p q) p)))
(define (my_cdr z)
  (z (lambda (p q) q)))

;;2.6
(define zero (lambda (f) (lambda (x) x)))

(define (add-1 n)
(lambda (f) (lambda (x) (f ((n f) x)))))
  