#lang racket
(require "tools.rkt")
(print-as-expression #f)
(pretty-print-abbreviate-read-macros #f)
(define-syntax example
  (syntax-rules ()
    ((_ e) (begin (newline)
                  (pretty-print 'e)
                  (displayln "==>")
                  (time (pretty-print e))))))
(define-syntax examples
  (syntax-rules ()
    ((_ e ...) (begin (example e) ...))))

(define (var? x)
  (and (symbol? x) (string-prefix? (symbol->string x) "?")))
(define (vars d)
  (remove-duplicates
    (let loop ((d d))
      (cond ((var? d) (list d))
            ((pair? d) (append (loop (car d)) (loop (cdr d))))
            ((vector? d) (loop (vector->list d)))
            (else '())))))

(define env-empty '())
(define (walk env d)
  (cond ((var? d) (let ((b (assoc d env)))
                    (if b (walk env (cdr b)) d)))
        (else     d)))
(define (walk* env d)
  (define (loop d) (walk* env d))
  (cond ((pair? d)   (cons (loop (car d)) (loop (cdr d))))
        ((vector? d) (vector-map loop d))
        ((var? d)    (let ((b (assoc d env)))
                       (if b (loop (cdr b)) d)))
        (else        d)))
(define (occurs? env v x)
  (define (loop d) (occurs? env v (walk env d)))
  (or (eqv? v x)
      (and (pair? x) (or (loop (car x)) (loop (cdr x))))
      (and (vector? x) (loop (vector->list x)))))
(define (rename-vars d)
  (walk* (map (lambda (v) (cons v (gensym v))) (vars d)) d))
(define (rename-?-vars d)
  (cond ((eq? d '?)  (gensym '?))
        ((pair? d)   (cons (rename-?-vars (car d)) (rename-?-vars (cdr d))))
        ((vector? d) (vector-map rename-?-vars d))
        (else        d)))

(define (unify-var env v x)
  (and (not (occurs? env v x))
       (cons (cons v x) env)))
(define (unify/env env x y)
  (and env
       (let ((x (walk env x)) (y (walk env y)))
         (cond ((eqv? x y) env)
               ((var? x) (unify-var env x y))
               ((var? y) (unify-var env y x))
               ((and (pair? x) (pair? y))
                (unify/env (unify/env env (car x) (car y))
                           (cdr x) (cdr y)))
               (else #f)))))
(define (unify x y) (unify/env env-empty x y))
(define (unifier x y) (walk* (unify x y) x))

(define empty-database (hash))
(define *database* empty-database)
(define (clause-head c)        (car c))
(define (clause-body c)        (cdr c))
(define (predicate relation)   (car relation))
(define (predicate->clauses p) (hash-ref *database* p '()))
(define (add-clause! c)
  (define p (predicate (clause-head c)))
  (unless (and (symbol? p) (not (var? p))) (error "invalid predicate:" p))
  (set! *database*
    (hash-set *database* p
              (append (predicate->clauses p) (list c)))))
(define (remove-predicate! p) (hash-remove *database* p))
(define (clear-database!) (set! *database* empty-database))

(define (prove env goal)
  (let outer-loop ((clauses (predicate->clauses (predicate goal))))
    (if (null? clauses) '()
      (let ((new-clause (rename-vars (car clauses))))
        (let loop ((envs (prove* (unify/env env goal (clause-head new-clause))
                                 (clause-body new-clause))))
          (if (stream-empty? envs) (outer-loop (cdr clauses))
            (stream-cons (stream-first envs)
                         (loop (stream-rest envs)))))))))
(define (prove* env goals)
  (cond ((not env)     '())
        ((null? goals) (list env))
        (else (let outer-loop ((s1s (prove env (car goals))))
                (if (stream-empty? s1s) '()
                  (let loop ((envs (prove* (stream-first s1s) (cdr goals))))
                    (if (stream-empty? envs) (outer-loop (stream-rest s1s))
                      (stream-cons (stream-first envs)
                                   (loop (stream-rest envs))))))))))
(define (top-level-prove count goals)
  (define answers
    (stream-map (lambda (env)
                  (map (lambda (v) `(,v = ,(walk* env v))) (vars goals)))
                (prove* env-empty goals)))
  (cond ((not count)
         (let loop ((answers answers))
           (unless (or (stream-empty? answers) (eof-object? (read-line)))
             (pretty-print (stream-first answers))
             (loop (stream-rest answers)))))
        ((and (number? count) (<= 0 count))
         (let loop ((answers answers) (count count))
           (if (= count 0) '()
             (cons (stream-first answers)
                   (loop (stream-rest answers) (- count 1))))))
        (else (stream->list answers))))

(define-syntax <-
  (syntax-rules () ((_ . clause) (add-clause! (rename-?-vars 'clause)))))
(define-syntax ?-n
  (syntax-rules () ((_ n . goals) (top-level-prove n (rename-?-vars 'goals)))))
(define-syntax ?-*
  (syntax-rules () ((_ . goals) (?-n -1 . goals))))
(define-syntax ?-
  (syntax-rules () ((_ . goals) (?-n #f . goals))))

(examples
  (unify '(?x + 1) '(2 + ?y))
  (unify '?x '?y)
  (unify '(?x ?x) '(?y ?y))
  (unify '(?x ?x ?x) '(?y ?y ?y))
  (unify '(?x ?y) '(?y ?x))
  (unify '(?x ?x a) '(?y ?y ?y))
  (unify '?x '(f ?x))
  (unify '(f ?x) '(f ?y))
  (unify '(?a + ?a = 0) '(?x + ?y = ?y))
  (unify '(?x ?y a) '(?y ?x ?x))
  (unify '(?x ?y) '((f ?y) (f ?x)))
  (unify '(?x ?y ?z) '((?y ?z) (?x ?z) (?x ?y)))
  (unify 'a 'a)
  (unify '(f (?x ?y a) (?y ?x ?x)) '(f ?z ?z))

  (unifier '(?a + ?a = 0) '(?x + ?y = ?y))
  (unifier '(?a + ?a = 2) '(?x + ?y = ?y))
  (unifier '(?x ?y a) '(?y ?x ?x))
  (unifier '((?a * ?x ^ 2) + (?b * ?x) + ?c)
           '(?z + (4 * 5) + 3))
  )

(<- (likes Kim Robin))
(<- (likes Sandy Lee))
(<- (likes Sandy Kim))
(<- (likes Robin cats))
(<- (likes Sandy ?x) (likes ?x cats))
(<- (likes Kim ?x) (likes ?x Lee) (likes ?x Kim))
(<- (likes ?x ?x))

(examples
  (?-* (likes Robin Lee))
  (?-* (likes Sandy ?who))
  (?-* (likes ?who Sandy))
  (?-* (likes ?who Lee))
  (?-* (likes ?x ?y) (likes ?y ?x))
  )

(<- (member ?item (?item . ?rest)))
(<- (member ?item (?x . ?rest)) (member ?item ?rest))
;; Alternative 1
;(<- (member ?item ?list)
    ;(= ?list (?item . ?rest)))
;(<- (member ?item ?list)
    ;(= ?list (?x . ?rest))
    ;(member ?item ?rest))
;; Alternative 2
;(<- (member ?item ?list)
    ;(= ?list (?first . ?rest))
    ;(or (= ?item ?first)
        ;(member ?item ?rest))))

(<- (length () 0))
(<- (length (?x . ?y) (1+ ?n)) (length ?y ?n))

(<- (= ?x ?x))

(examples
  (?-* (member 2 (1 2 3)))
  (?-* (member 2 (1 2 3 2 1)))
  (?-* (member ?x (1 2 3)))
  (?-* (length (a b c d) ?n))
  (?-* (length ?list (1+ (1+ 0))))
  (?-* (length ?l (1+ (1+ 0))) (member a ?l))
  (?-* (length ?l (1+ (1+ (1+ (1+ 0)))))
       (member d ?l) (member a ?l) (member c ?l) (member b ?l)
       (= ?l (a b c d))))

(<- (nextto ?x ?y ?list) (iright ?x ?y ?list))
(<- (nextto ?x ?y ?list) (iright ?y ?x ?list))
(<- (iright ?left ?right (?left ?right . ?rest)))
(<- (iright ?left ?right (?x . ?rest))
    (iright ?left ?right ?rest))

(<- (zebra ?h ?w ?z)
    ;; Each house is of the form:
    ;; (house nationality pet cigarette drink house-color)
    (= ?h ((house norwegian ? ? ? ?)
           ?
           (house ? ? ? milk ?) ? ?))
    (member (house englishman ? ? ? red) ?h)
    (member (house spaniard dog ? ? ?)   ?h)
    (member (house ? ? ? coffee green)   ?h)
    (member (house ukrainian ? ? tea ?)  ?h)
    (iright (house ? ? ? ? ivory)
            (house ? ? ? ? green) ?h)
    (member (house ? snails winston ? ?) ?h)
    (member (house ? ? kools ? yellow)   ?h)
    (nextto (house ? ? chesterfield ? ?)
            (house ? fox ? ? ?) ?h)
    (nextto (house ? ? kools ? ?)
            (house ? horse ? ? ?) ?h)
    (member (house ? ? luckystrike orange-juice ?) ?h)
    (member (house japanese ? parliaments ? ?) ?h)
    (nextto (house norwegian ? ? ? ?)
            (house ? ? ? ? blue) ?h)
    ;; Questions:
    (member (house ?w ? ? water ?) ?h)
    (member (house ?z zebra ? ? ?) ?h))

(examples (?-* (zebra ?houses ?water-drinker ?zebra-owner)))

(<- (append () ?ys ?ys))
(<- (append (?x . ?xs) ?ys (?x . ?xsys))
    (append ?xs ?ys ?xsys))

(<- (prove ?goal) (prove* (?goal)))

(<- (prove* ()))
(<- (prove* (?goal . ?goals))
    (clause (<- ?goal . ?body))
    (append ?body ?goals ?new-goals)
    (prove* ?new-goals))

(<- (clause (<- (mem ?x (?x . ?y)))))
(<- (clause (<- (mem ?x (? . ?z)) (mem ?x ?z))))

(examples
  (?-* (append ?x ?y (1 2 3 4)))
  (?-* (prove (mem ?x (1 2 3))))
  )

;; Interactive examples
(examples
  (?- (member 2 ?list))
  (?- (member ?item ?list))
  (?- (length ?list ?n))
  ;; Asking for more than two answers will infinite loop.
  (?- (member a ?l) (length ?l (1+ (1+ 0))))
  )
