;    ATTOLISP.ASM
;
;    6502 ASSEMBLER IMPLEMENTATION OF A LISP TOO SMALL TO USE
;
;

R0   	=	$02             ; REGISTERS
R0H     =   $03
R1   	=	$04
R1H     =   $05
R2   	=	$06
R2H     =   $07
R3   	=	$08
R3H     =   $09

XPTR	=	$0A				; S-EXPRESSION SPACE POINTER
XPTRH	=	$0B
SCOPE 	=	$0C             ; CURRENT SCOPE POINTER
SCOPEH	=	$0D
RSPTR   =   $0E             ; RESULT STACK POINTER
RSPTRH	=	$0F
QPTR	=	$10				; QUOTE SPACE POINTER
QPTRH	=	$11
FNPTR	=	$12				; FUNCTION SPACE POINTER
FNPTRH	=	$13
ARGPT	=	$14				; ARGS POINTER
ARGSPT	=	$15				; ARGS STACK POINTER
MPTR	=	$16				; MACRO SPACE POINTER
MPTRH	=	$17
INPTR	=	$18				; INPUT POINTER
INPTRH	=	$19
OUPTR	=	$1A				; OUTPUT POINTER
OUPTRH	=	$1B
SPPTR	=	$1C				; SCOPE STACK POINTER
SPPTRH	=	$1D

ENDPGE  =   $FF             ; END OF ANY PAGE

; STACK POINTER USES PAGE 1

XSPCE	=	$0200			; S-EXPRESSION SPACE
SCOPES  =   $3C00			; SCOPE SPACE
ARGSP 	=	$EF00			; ARGUMENT POINTER STACK
SPSTCK	=	$F000			; SCOPE POINTER STACK
RSTCK 	=	$F100			; RESULT STACK 
QPTRS	=	$F200			; QUOTE POINTERS
FNS		=	$F300			; FUNCTIONS
ARGS	=	$F400			; ARGS
MACROS	=	$F500			; MACRO SPACE
INPUT   =   $F600		    ; INPUT
OUTPUT 	=   $F700		    ; OUPUT

SCPSZ   =   64              ; SIZE OF SCOPE 2 * (26 LETTERS + 6 NUMBERS)
CELLSZ	=	4				; SIZE OF CONS CELL
PROCSZ	=	5				; SIZE OF PROC (FN, MACRO)
PROCSY  = 	0				; OFFSET OF PROC SYMBOL TABLE POINTER
PROCAL	= 	2				; OFFSET OF PROC ARGUMENT LIST POINTER
PROCSX	= 	3				; OFFSET OF PROC S-EXPRESSION POINTER

VMSK	=	$80				; VALUES (CHAR AND INT) MASK
VMSKC	=	$7F				; COMPLEMENT
SYMMSK	=	$D0				; SYMBOL MASK
SNCODE	=	$00				; SYMBOL AND NUMBER (AND OTHER) CODE
BCCODE	=	$01				; BUILT INS AND CHAR CODE
ADMSK	=	$FE 			; ADDRESS MASK
XMSK	=	$80				; S-EXPRESSION MASK
XMSKC	=	$7F				; COMPLEMENT
NIL		=	$40				; NIL LOW ORDER (SNCODE, NIL)
ONE 	=	$81				; ONE LOW ORDER (SNCODE, ONE)
ARGEND	=	$41				; END OF ARGUMENTS FLAG

LPAREN	=	$28				; ( OPEN S-EXPRESSION
RPAREN	=	$29				; ) CLOSE S-EXPRESSION
LBRKT	=	$5B				; [ OPEN ARGUMENT LIST
RBRKT	=	$5D				; ] CLOSE ARGUMENT LIST
FDEF	=	$66				; F FUNCTION
MDEF	=	$6D				; M MACRO
QUOTE 	=	$27				; ' QUOTE
CHAR 	=	$22				; " CHARACTER
NUMBR 	=	$23				; # NUMBER

AC 		=	$41				; A (LOWEST SYMBOL LETTER)
ACM		=	$40				; ONE LESS THAN THAT
ZC 		=	$5A				; Z (HIGHEST SYMBOL LETTER)
ZCP		=	$5B				; ONE MORE THAN THAT
ZEROC	=	$30				; CHAR 0
ZEROCM	=	$2F				; ONE LESS THAN THAT
ZSDLTA	=	$16				; TRANSLATE CHAR 0 TO SYMBOL VALUE
ONEC	=	$31				; CHAR 1
LETTRS 	=	26				; NUMBER OF LETTERS
FIVEC	=	$35				; CHAR 5 (HIGHEST SYMBOL NUMBER)
SIXC	=	$36				; ONE MORE THAN THAT

; BUILT INS

DEFC 	=	$64				; D DEFINE SYMBOL
EQUALC 	=	$3D				; = EQUALS
LESSC 	=	$3C				; < LESS THAN
GREATC	=	$3E				; > GREATER THAN
NOTC 	=	$21				; ! NOT
ANDC 	=	$5E				; ^ AND
ORC		=	$7C				; | OR
ADDC 	=	$2B				; + ADD
CONSC 	=	$63				; C CONS
CARC 	=	$61				; A CAR
CDRC 	= 	$72				; R CDR
EVALC 	=	$65				; E EVAL
TESTC   =	$74				; T TEST
PRINTC 	=	$70				; P PRINT
GROUPC	=	$67				; G GROUP

*       =   $F800

        LDA #0      

; S-EXPRESSION POINTER

        STA *XPTR
        LDX	#>XSPCE
        STX	*XPTRH

; SCOPE POINTER

        STA *SCOPE
        LDX #>SCOPES
        STX *SCOPEH

; SCOPE STACK POINTER

        STA *SPPTR
        LDX #>SPSTCK
        STX *SPPTRH

; RESULT STACK POINTER

		STA *RSPTR
		LDX	#>RSTCK
		STX *RSPTRH

; QUOTE POINTER

		STA *QPTR
		LDX #>QPTRS
		STX *QPTRH

; FUNCTIONS POINTER

		STA *FNPTR
		LDX #>FNS
		STX *FNPTRH

; ARGS AND ARG STACK POINTER

		STA *ARGPT
		STA *ARGSPT

; MACROS POINTER

		STA *MPTR
		LDX #>MACROS
		STX *MPTRH

; INPUT POINTER

		STA *INPTR
		LDX #>INPUT
		STX *INPTRH

; OUTPUT POINTER

		STA *OUPTR
		LDX #>OUTPUT
		STX *OUPTRH


; CLEAR GLOBAL SYMBOL TABLE

		LDY	#SCPSZ
CLGSL	DEY
		STA (SCOPE),Y
		BNE	CLGSL

; SET UP SYMBOL TABLE STACK POINTER

        LDY	#0
        STA (SPPTR),Y
        INY
        LDA #>SCOPES
        STA (SPPTR),Y        

; CLEAR OUTPUT

		LDA	#$20			; SPACE
		LDY	#0
CLOUTL	DEY
		STA (OUPTR),Y
		BNE	CLOUTL

; PARSE AND EXECUTE INPUT BUFFER (REPL)

REPL	JSR	NXTIN
		CMP	#0
		BEQ	DONE
		JSR DELAY
		JSR	PARSE
		JSR DELAY
		JSR	TEVAL
		JSR	PRINT
		JMP REPL

;  FINISH

DONE    BRK

;
;  TEST TYPES (TOP OF STACK)
;  ZERO FLAG 1 IF TRUE, 0 OTHERWISE
;

;  IS NUMBER

ISNUMB	LDA #SNCODE
		STA *R0H
		LDA	#VMSK
		STA *R0
		JMP TTYP

;  IS SYMBOL

ISSYMB	JSR ISNIL
		BEQ NOTSYM
		LDA #SNCODE
		STA *R0H
		LDA #0
		STA *R0
		JMP TTYP

NOTSYM	LDA #1					; CLEAR Z FLAG
		RTS

;  IS CHARACTER

ISCHAR	LDA #BCCODE
		STA *R0H
		LDA	#VMSK
		STA *R0
		JMP TTYP
		
;  IS BUILT IN

ISBILT	LDA #BCCODE
		STA *R0H
		LDA	#0
		STA *R0

TTYP	LDY #1
		LDA	(RSPTR),Y
		CMP *R0H
		BNE NOTTYP
		DEY
		LDA (RSPTR),Y
		AND #VMSK
		CMP *R0
NOTTYP	RTS

;  IS IN PAGE

INPAGE 	LDY #1
		CMP (RSPTR),Y
		RTS

;  IS QUOTE

ISQUOT	LDA #>QPTRS
		JSR INPAGE
		RTS

;  IS FUNCTION

ISFN	LDA #>FNS
		JSR INPAGE
		RTS

;  IS MACRO

ISM 	LDA #>MACROS
		JSR INPAGE
		RTS

;  IS EXPRESSION

ISSX	LDY	#1
		LDA	(RSPTR),Y
		CMP	#>XSPCE
		BPL	ADTR
		LDA	#1							; IS NOT S-EXPRESSION
		RTS

ADTR	AND	#XMSK
		RTS

; IS NIL

ISNIL	LDY #0
		LDA	(RSPTR),Y
		CMP #NIL
		BNE NOTNIL
		INY
		LDA	(RSPTR),Y
		CMP #SNCODE
NOTNIL	RTS

;
;  PARSING FUNCTIONS
;

; PARSE CHAR

PCHAR	JSR	NXTIN
		ORA	#VMSK
		LDY	#0
		STA (RSPTR),Y
		INY
		LDA	#BCCODE
		STA (RSPTR),Y
		RTS

; PARSE NUMBER 

PNUMBR	JSR	NXTIN
		SEC
		SBC	#ZEROC
		ORA #VMSK
		LDY	#0
		STA (RSPTR),Y
		INY
		LDA	#SNCODE
		STA (RSPTR),Y
		RTS

; PARSE QUOTE

PQUOTE	JSR NXTIN
		JSR PARSE
		LDY #0
		LDA (RSPTR),Y
		STA (QPTR),Y
		INY
		LDA (RSPTR),Y
		STA (QPTR),Y
		LDA *QPTRH
		STA (RSPTR),Y		
		LDA *QPTR
		DEY
		STA (RSPTR),Y		
		INC *QPTR
		INC *QPTR		
		RTS

; PARSE S-EXPRESSION

PXS		JSR NXTIN
		CMP #RPAREN
		BNE ASX

MKNIL	LDY #0					; MKNIL ALSO GETS CALLED FROM ALL OVER THE PLACE
		LDA #NIL
		STA (RSPTR),Y
		INY
		LDA #SNCODE
		STA (RSPTR),Y
		RTS

ASX		JSR PARSE
		INC *RSPTR
		INC *RSPTR
		JSR PXS
		JSR MKCONS
		RTS

; PARSE SYMBOL

PSYMB	JSR COMPS

; MAKE A SYMBOL WORD FROM A SYMBOL BYTE

MKSYM	LDY #0
		STA (RSPTR),Y
		LDA #SNCODE
		INY
		STA (RSPTR),Y
		RTS

;  NEXT CHAR IS IN A

PARSE	CMP	#CHAR
		BEQ	PCHAR
		CMP #NUMBR
		BEQ	PNUMBR
		CMP #QUOTE
		BEQ	PQUOTE
		CMP #LPAREN
		BEQ	PXS
		CMP #FDEF
		BEQ	PFUNC
		CMP #MDEF
		BEQ	PMACRO
		JSR	TSTSYM
		BEQ	PSYMB

; OTHERWISE BUILT IN

		LDY	#0
BILTL	CMP BILTC,Y
		BEQ FNDBLT
		INY
		CPY #BILTN
		BNE BILTL
		JMP	DONE 			; NOT FOUND

FNDBLT	TYA
		ASL A
		LDY #0
		STA (RSPTR),Y
		INY
		LDA #BCCODE
		STA (RSPTR),Y
		RTS
		
PFUNC	LDY #0
		LDA *FNPTR
		STA (RSPTR),Y
		LDA *FNPTRH
		INY
		STA (RSPTR),Y
		LDA *FNPTR
		CLC
		ADC #PROCSZ
		STA *FNPTR
		JMP PPROC

PMACRO	LDY #0
		LDA *MPTR
		STA (RSPTR),Y
		LDA *MPTRH
		INY
		STA (RSPTR),Y
		LDA *MPTR
		CLC
		ADC #PROCSZ
		STA *MPTR

PPROC	JSR NXTIN					; SKIP [
		INC *RSPTR
		INC *RSPTR
		LDY #0
		LDA (SPPTR),Y
		STA (RSPTR),Y
		INY
		LDA (SPPTR),Y
		STA (RSPTR),Y
		INC *RSPTR
		INC *RSPTR
		LDY #0
		LDA *ARGPT
		STA (RSPTR),Y
		INC *RSPTR
		
PROCL	JSR NXTIN
		CMP #RBRKT
		BEQ ENDA
		JSR DELAY
		JSR COMPS
		LDY *ARGPT
		STA ARGS,Y
		INC *ARGPT
		JMP PROCL

ENDA	LDY *ARGPT
		LDA #ARGEND
		STA ARGS,Y
		INC *ARGPT

		JSR NXTIN
		JSR PARSE

		LDA *RSPTR
		SEC
		SBC #PROCSZ
		STA *RSPTR
		JSR CPYR0
		INC *RSPTR
		INC *RSPTR

		LDY #0
PROCPY	LDA (RSPTR),Y
		STA (R0),Y
		INY
		CPY #PROCSZ
		BNE PROCPY
		
		DEC *RSPTR
		DEC *RSPTR
		
		RTS


;  BUILT INS

BILTC	
.BYTE DEFC
.BYTE EQUALC
.BYTE LESSC
.BYTE GREATC
.BYTE NOTC
.BYTE ANDC
.BYTE ORC
.BYTE ADDC
.BYTE CONSC
.BYTE CARC
.BYTE CDRC
.BYTE EVALC
.BYTE TESTC
.BYTE GROUPC
.BYTE PRINTC

BILTN =	15

BILTE
.WORD EDEF
.WORD EEQUAL
.WORD ELESS
.WORD EGREAT
.WORD ENOT
.WORD EAND
.WORD EORW
.WORD EADD
.WORD ECONS
.WORD ECAR
.WORD ECADR
.WORD EEVAL
.WORD ETEST
.WORD EGROUP
.WORD EPRINT

;
;  BOOLEAN - NIL IS FALSE, ALL ELSE IS TRUE
;

; DEFINE SYMBOL

EDEF	LDX #2
		JSR FCHARG
		INC *RSPTR
		INC *RSPTR		
		LDX #4
		JSR FCHARG
		JSR EVALR
		JSR SETSYM
		JSR MKNIL
		RTS

SETSYM	JSR CPYR0
		DEC *RSPTR
		DEC *RSPTR
		LDY #$1
		LDA (SPPTR),Y
		STA *R1H
		DEY
		LDA (SPPTR),Y
		STA *R1
		LDA (RSPTR),Y
		TAY
		LDA *R0
		STA (R1),Y
		INY
		LDA *R0H
		STA (R1),Y
		RTS

		
; CHECK FOR EQUALITY
; NUMBERS ONLY

EEQUAL	JSR GET2N
		CMP *R0
		BNE SETNEQ
		JSR MKONE
		RTS

SETNEQ 	JSR MKNIL
		RTS

; CHECK FOR LESS THAN

ELESS	JSR GET2N
		CMP *R0
		BEQ SETNLT
		BPL SETNLT
		JSR MKONE
		RTS

SETNLT 	JSR MKNIL
		RTS

; CHECK FOR GREATER THAN

EGREAT  JSR GET2N
		CMP *R0
		BEQ SETNGT
		BMI SETNGT
		JSR MKONE
		RTS

SETNGT 	JSR MKNIL
		RTS

; NEGATION

ENOT	JSR MONOP
		JSR ISNIL
		BEQ NSETT
		JSR MKNIL
		RTS

NSETT	JSR MKONE
		RTS

; AND

EAND	JSR BINOP
		JSR ISNIL
		BEQ ASETF1
		DEC *RSPTR
		DEC *RSPTR
		JSR ISNIL
		BEQ ASETF2 
		JSR MKONE
		RTS

ASETF1	DEC *RSPTR
		DEC *RSPTR
ASETF2	JSR MKNIL
		RTS

; OR

EORW 	JSR BINOP
		JSR ISNIL
		BNE ODEC
		DEC *RSPTR
		DEC *RSPTR
		JSR ISNIL
		BNE OSETT
		RTS

ODEC	DEC *RSPTR
		DEC *RSPTR
OSETT	JSR MKONE
		RTS

; ADD NUMBERS

EADD	JSR GET2N
		CLC
		ADC *R0
		ORA #VMSK
		LDY #0
		STA (RSPTR),Y
		INY
		LDA #SNCODE
		STA (RSPTR),Y
		RTS


; CONS TO A LIST

ECONS	JSR BINOP
		DEC *RSPTR
		DEC *RSPTR
		JSR MKCONS
		RTS

; FIRST LIST ELEMENT

ECAR	JSR CPYR0
		JSR CPYA0R
		RTS

; REST OF LIST

ECADR	JSR CPYR0
		INC *R0
		INC *R0
		JSR CPYA0R
		RTS

; EVAL

EEVAL 	JSR ISQUOTE
		BNE DOEVAL
		JSR CPYR0
		JSR CPYA0R
DOEVAL	JMP	EVALR

; BRANCHING PRIMITIVE
; EVEN SIZE LIST
; TEST, EXPRESSION PAIRS
; EVALUATE FIRST EXPRESSION WHERE TEST IS TRUE
; OTHERWISE NIL

ETEST	LDX #2
		JSR FCHARG
		BEQ ETNFND
		JSR EVALR
		JSR ISNIL
		BNE ETFND
		LDX #2
		JSR FCHARG
		JMP ETEST

ETFND	LDX #2
		JSR FCHARG
		JSR EVALR
		RTS

ETNFND 	JSR MKNIL
		RTS
		
;  GROUP - EVAL EVERY CAR IN A LIST

EGROUP 	LDX #2
		JSR FCHARG
		BEQ EGDON
		JSR EVALR
		JMP EGROUP

EGDON	RTS

;  PRINT

EPRINT	JSR MONOP
		JSR PRINT
		JSR MKNIL
		RTS

;
; UTILITY FUNCTIONS
;

; GET 2 NUMERIC ARGUMENTS
; PUT THEM IN R0 AND A

GET2N	JSR	BINOP
		LDY #0
		LDA (RSPTR),Y
		AND #VMSKC
		STA R0
		DEC *RSPTR
		DEC *RSPTR
		LDA (RSPTR),Y
		AND #VMSKC
		RTS

;  DEBUGGING DELAY

DELAY	LDY #$80
DELAYL	DEY
		BNE	DELAYL
		RTS


;  DEBUGGER

DEBUG 	JSR OUT
		LDA	*RSPTR
		JSR OUT
		LDA *RSPTRH
		JSR OUT
		LDY #0
		LDA (RSPTR),Y
		JSR OUT
		INY
		LDA (RSPTR),Y
		JSR OUT
		RTS

; GET ARGUMENT FOR MONADIC OP

MONOP 	LDX #2
		JSR FCHARG
		JSR EVALR
		RTS

; GET ARGUMENTS FOR BINARY OP

BINOP	JSR MONOP
		INC *RSPTR
		INC *RSPTR
		LDX #4
		JSR FCHARG
		JSR EVALR
		RTS

; FETCH AN ARGUMENT	
; SX POINTER IS X REGISTER BYTES DOWN THE STACK

FCHARG	STX	*R1
		LDA *RSPTR
		SEC
		SBC *R1
		STA *RSPTR 
		JSR ISNIL
		BEQ FDONE
		JSR ECADR
		JSR ISNIL
		BEQ FDONE
		JSR CPYR0
		LDA *RSPTR
		CLC
		ADC *R1
		STA *RSPTR
		JSR CPYA0R
		LDA #1				; CLEAR ZERO FLAG
		RTS

FDONE	LDA *RSPTR
		CLC
		ADC *R1
		STA *RSPTR
		LDA #0				; SET ZERO FLAG
		RTS		

; DUPLICATE TOP OF STACK

DUP 	JSR CPYR0
		INC *RSPTR
		INC *RSPTR
		JSR CPY0R
		RTS

; INVERSE OF DUPLICATE TOP OF STACK

DEDUP 	JSR CPYR0
		DEC *RSPTR
		DEC *RSPTR
		JSR CPY0R
		RTS

; COMPUTE A SYMBOL BYTE

COMPS	CMP #SIXC
		BMI PSN
		SEC
		SBC #AC
		BPL PSD
PSN		SEC
		SBC #ZSDLTA
PSD		ASL A
		RTS

; SET ZERO FLAG IF CHAR IS A SYMBOL

TSTSYM	CMP #ZEROC
		BEQ ETSYM
		BMI ETSYM
		CMP #FIVEC
		BEQ ETSYM
		BMI SETZ
		CMP #AC
		BEQ ETSYM
		BMI ETSYM
		CMP #ZC
		BEQ ETSYM
		BPL ETSYM
SETZ	LDY #0 				; SET EQUAL FLAG
ETSYM	RTS


; NEXT INPUT CHARACTER

NXTIN	LDY	#0
		LDA (INPTR),Y
		INC *INPTR
		RTS

; OUTPUT A CHARACTER

OUT 	LDY #0
		STA (OUPTR),Y
		INC *OUPTR
		RTS

;  COPY RESULT STACK TO RO

CPYR0	LDY	#0
		LDA	(RSPTR),Y
		STA *R0
		INY
		LDA	(RSPTR),Y
		STA *R0H
		RTS

;  COPY R0 TO RESULT STACK

CPY0R 	LDY #0
		LDA *R0
		STA (RSPTR),Y
		INY
		LDA *R0H
		STA (RSPTR),Y
		RTS

;  COPY DATA POINTED TO BY R0 TO RESULT STACK

CPYA0R	LDY	#0
		LDA (R0),Y
		STA (RSPTR),Y
		INY
		LDA (R0),Y
		STA (RSPTR),Y
		RTS

;  COPY RESULT STACK TO LOCATION POINTED TO BY R0

CPYRA0	LDY	#0
		LDA (RSPTR),Y
		STA (R0),Y
		INY
		LDA (RSPTR),Y
		STA (R0),Y
		RTS

; CREATE A CONS CELL
; STACK HOLDS CAR AND CDR

MKCONS	DEC *RSPTR
		DEC *RSPTR
		LDY #0
CONSL	LDA (RSPTR),Y
		STA (XPTR),Y
		INY
		CPY #CELLSZ
		BNE	CONSL
		
		LDY #0
		LDA *XPTR
		STA (RSPTR),Y
		INY
		LDA *XPTRH
		STA (RSPTR),Y

		LDA *XPTR
		CLC
		ADC #CELLSZ
		STA *XPTR
		BCC MKCD
		INC XPTRH

MKCD	RTS

;  PUT A NUMERIC ONE ON TOP OF THE STACK

MKONE	LDY #0
		LDA #ONE
		STA (RSPTR),Y
		INY
		LDA #SNCODE
		STA (RSPTR),Y
		RTS

;
; EVAL ROUTINES
;

; EVAL S-EXPRESSION

ESX 	JSR CPYR0
		INC *RSPTR
		INC *RSPTR
		JSR CPYA0R
		JSR ISSYMB
		BNE ENSYMB
		JSR ESYMB
ENSYMB	JSR ISBILT
		BNE ENBILT
		JSR EBILT
		JMP CLNUP

ENBILT	JSR ISFN
		BNE ENFN
		JSR EFN
		JMP CLNUP
		
ENFN	JSR ISM
		BNE ENM
		JSR EM

CLNUP	JSR DEDUP
		RTS

ENM		BRK

; TOP LEVEL EVAL

TEVAL	JSR	ISQUOT
		BNE EVALR
		JSR CPYR0
		JSR CPYA0R
		RTS

; RECURSIVELY EVALUATE THE EXPRESSION ON THE TOP OF THE STACK

EVALR 	JSR ISNIL
		BEQ EDONE
		JSR ISCHAR
		BEQ EDONE
		JSR ISNUMB
		BEQ EDONE
		JSR ISSYMB
		BEQ ESYMB
		JSR ISBILT
		BEQ EDONE
		JSR ISQUOT
		BEQ EDONE
		JSR ISFN
		BEQ EDONE
		JSR ISM
		BEQ EDONE
		JSR ISSX
		BEQ ESX
		BRK					; NOTHING FOUND

; SYMBOL

ESYMB	LDY	#1
		LDA (SPPTR),Y
		STA *R0H
		DEY
		LDA (SPPTR),Y
		STA *R0
		LDA (RSPTR),Y
		TAY
		LDA (R0),Y
		STA *R1
		INY
		LDA (R0),Y
		STA *R1H
		LDY #0
		LDA *R1
		STA (RSPTR),Y
		INY
		LDA *R1H
		STA (RSPTR),Y
		JSR ISSYMB
		BNE SYDONE
		JSR ESYMB
SYDONE	RTS

; DO NOTHING

EDONE	RTS

; BUILT IN

EBILT	LDY #0
		LDA (RSPTR),Y
		TAX
		LDA BILTE,X
		STA *R0
		INX
		LDA BILTE,X
		STA *R0H
		JMP (R0)

; FUNCTION

EFN		LDA #1
		BNE EPROC

; MACRO

EM 		LDA #0

; FUNCTION AND MACRO

EPROC	PHP					; HANG ONTO FN/MACRO FLAG

; ALLOCATE AND FILL SYMBOL TABLE PUT IT ON THE SYMBOL TABLE STACK

		LDA #$10
		JSR DEBUG

		LDY #1
		INC *SPPTR
		INC *SPPTR
		LDA *SCOPEH
		STA *R2H
		STA (SPPTR),Y
		DEY
		LDA *SCOPE
		STA *R2
		STA (SPPTR),Y
		CLC
		ADC #SCPSZ
		STA *SCOPE
		BCC FILL
		INC *SCOPEH

FILL	LDY #PROCSY
		JSR CPYR0
		LDA (R0),Y
		STA *R1
		INY
		LDA (R0),Y
		STA *R1H
		LDY #0
FILLL	LDA (R1),Y
		STA (R2),Y
		INY
		CPY #SCPSZ 
		BNE FILLL

; FILL IN ARGUMENTS
		
		LDA #$11
		JSR DEBUG

		LDY #PROCAL
		LDA (R0),Y
		LDY *ARGSPT
		INC *ARGSPT
		STA ARGSP,Y

		INC *RSPTR
		INC *RSPTR
		LDY #1
		LDA #SNCODE
		STA (RSPTR),Y

		LDA #$12
		JSR DEBUG

		JSR DELAY

ARGL	LDX *ARGSPT
		LDA ARGSP,X
		INC ARGSP,X
		TAY
		LDA ARGS,Y
		STA (RSPTR),Y
		INC *RSPTR    ????
		
		INC *RSPTR

		LDA #$13
		JSR DEBUG

		LDX #6
		JSR FCHARG
		BEQ FNDONE

		PLP
		PHP
		BEQ FAM
		JSR	EVALR
FAM		JSR SETSYM	
		JMP ARGL

FNDONE	PLP
		
		LDA #$14
		JSR DEBUG

		DEC *RSPTR
		DEC *RSPTR
		DEC *RSPTR
		DEC *RSPTR

		JSR CPYR0
		LDY #PROCSX
		LDA *R0
		STA (RSPTR),Y
		LDA *R0H
		INY
		STA (RSPTR),Y

		LDA #$15
		JSR DEBUG

		JSR ESX

		LDA #$16
		JSR DEBUG

		RTS
;
; PRINT ROUTINES
;

; PRINT CHARACTER

PNCHAR 	LDY #0
		LDA (RSPTR),Y
		AND #VMSKC
		JSR OUT
		RTS

; PRINT NUMBER

PNNUMB 	PHA
		LDA #NUMBR
		JSR OUT
		PLA
		LDY #0
		LDA (RSPTR),Y
		AND #VMSKC

		CMP #100
		BMI TENSQ
		CLC
		SBC #100
		PHA
		LDA #ONEC
		JSR OUT
		PLA

TENSQ	CMP #10
		BMI ONES

		LDX #ZEROC
		CLC
TENSL	INX
		SBC #10
		CMP #9
		BPL TENSL
		PHA
		TXA
		JSR OUT
		PLA

ONES	CLC
		ADC	#ZEROC
		JSR OUT
		RTS

; PRINT QUOTE 

PNQUOT	LDA	#QUOTE
		JSR OUT
		JSR CPYR0
		JSR CPYA0R
		JSR PRINT
		RTS

; PRINT BUILT IN

PNBILT	LDY #0
		LDA (RSPTR),Y
		CLC
		ROR A
		TAY
		LDA BILTC,Y
		JSR OUT
		RTS

; PRINT NIL

PNNIL	LDA	#LPAREN
		JSR OUT
		LDA #RPAREN
		JSR OUT
		RTS

; PRINT THE EXPRESSION ON THE TOP OF THE STACK

PRINT 	JSR ISCHAR
		BEQ PNCHAR
		JSR ISNUMB
		BEQ PNNUMB
		JSR ISQUOT
		BEQ PNQUOT
		JSR ISBILT
		BEQ PNBILT
		JSR ISNIL
		BEQ PNNIL
		JSR ISSX
		BEQ PNSX
		JSR ISSYMB
		BEQ PNSYMB
		JSR ISFN
		BEQ PNFN
		JSR ISM
		BEQ PNM
		BRK							; NOT FOUND

; PRINT S-EXPRESSION

PNSX 	JSR ISNIL
		BNE PNNNIL
		JSR PNNIL
		RTS
			
PNNNIL	LDA	#LPAREN
		JSR OUT
PNSXL	JSR CPYR0
		INC *RSPTR
		INC *RSPTR
		JSR CPYA0R
		JSR PRINT
		DEC *RSPTR
		DEC *RSPTR
		JSR CPYR0
		INC R0
		INC R0
		JSR CPYA0R
		JSR ISNIL
		BNE PNSXL

		LDA #RPAREN
		JSR OUT
		RTS

; PRINT SYMBOL

PNSYMB	LDY #0
		LDA (RSPTR),Y

; PRINT SYMBOL IN A

LPNSY	CLC
		ROR A
		CMP #LETTRS
		BPL NSYMB
		ADC #AC
		JSR OUT
		RTS

NSYMB	CLC
		ADC #ZSDLTA
		JSR OUT
		RTS

; PRINT FUNCTION

PNFN	LDA #FDEF
		JSR OUT
		JMP PNPROC	

; PRINT MACRO

PNM 	LDA #MDEF
		JSR OUT

; PRINT PROCEDURE (COMMON TO FUNCTION AND MACRO)

PNPROC 	LDA #LBRKT
		JSR OUT
		JSR CPYR0
		LDY #PROCAL
		LDA (R0),Y
		TAX
ARGL	LDA ARGS,X
		CMP #ARGEND
		BEQ ARDN
		JSR LPNSY
		INX
		JMP ARGL

ARDN 	LDA #RBRKT
		JSR OUT

		JSR CPYR0
		INC *RSPTR
		INC *RSPTR
		LDY #PROCSX
		LDX #0
		LDA (R0),Y
		STA (RSPTR,X)
		INY
		INC *RSPTR
		LDA (R0),Y
		STA (RSPTR,X)
		DEC *RSPTR
		JSR PRINT
		DEC *RSPTR
		DEC *RSPTR
		RTS
		
.END
