;    ATTOLISP.ASM
;
;    6502 ASSEMBLER IMPLEMENTATION OF A LISP TOO SMALL TO USE
;
;

R0   	=	$02             ; REGISTERS
R1   	=	$04
R2   	=	$06
R3   	=	$08

XPTR	=	$10				; S-EXPRESSION SPACE POINTER
SCOPE 	=	$12             ; CURRENT SCOPE POINTER
RSPTR   =   $14             ; RESULT STACK POINTER
QPTR	=	$16				; QUOTE SPACE POINTER
FNPTR	=	$18				; FUNCTION SPACE POINTER
MPTR	=	$1A				; MACRO SPACE POINTER
SPPTR	=	$1C				; SCOPE STACK POINTER
ARGPT	=	$1E				; ARGS POINTER
ARGSPT	=	$1F				; ARGS STACK POINTER
INPTR	=	$20				; INPUT POINTER

ENDPGE  =   $FF             ; END OF ANY PAGE

; STACK POINTER USES PAGE 1

ARGSP 	=	$0900			; ARGUMENT POINTER STACK
SPSTCK	=	$0A00			; SCOPE POINTER STACK
RSTCK 	=	$0B00			; RESULT STACK 
QPTRS	=	$0C00			; QUOTE POINTERS
FNS		=	$0D00			; FUNCTIONS
ARGS	=	$0E00			; ARGS
MACROS	=	$0F00			; MACRO SPACE
CODE	=	$1000
XSPCE	=	$1900			; S-EXPRESSION SPACE
SCOPES  =   $4000			; SCOPE SPACE

SCPSZ   =   64              ; SIZE OF SCOPE 2 * (26 LETTERS + 6 NUMBERS)
CELLSZ	=	4				; SIZE OF CONS CELL
PROCSZ	=	5				; SIZE OF PROC (FN, MACRO)
PROCSY  = 	0				; OFFSET OF PROC SYMBOL TABLE POINTER
PROCAL	= 	2				; OFFSET OF PROC ARGUMENT LIST POINTER
PROCSX	= 	3				; OFFSET OF PROC S-EXPRESSION POINTER

VMSK	=	$80				; VALUES (CHAR AND INT) MASK
SYMMSK	=	$D0				; SYMBOL MASK
SNCODE	=	$00				; SYMBOL AND NUMBER (AND OTHER) CODE
BCCODE	=	$01				; BUILT INS AND CHAR CODE
ADMSK	=	$FE 			; ADDRESS MASK
XMSK	=	$80				; S-EXPRESSION MASK
NIL		=	$40				; NIL LOW ORDER (SNCODE, NIL)
ONE 	=	$81				; ONE LOW ORDER (SNCODE, ONE)
ARGEND	=	$41				; END OF ARGUMENTS FLAG

OPNSX	=	"("				; OPEN S-EXPRESSION
CLSSX	=	")"				; CLOSE S-EXPRESSION
OPNARG	=	"["				; OPEN ARGUMENT LIST
CLSARG	=	"]"				; CLOSE ARGUMENT LIST
FDEF	=	"f"				; FUNCTION
MDEF	=	"m"				; MACRO
QUOTE 	=	"'"				; QUOTE
CHAR 	=	$22				; " CHARACTER
NUMBR 	=	"#"				; NUMBER

AC 		=	"A"				; LOWEST SYMBOL LETTER)
ZC 		=	"Z"				; Z (HIGHEST SYMBOL LETTER)
ZEROC	=	"0"				; CHAR 0
ZSDLTA	=	$16				; TRANSLATE CHAR 0 TO SYMBOL VALUE
ONEC	=	"1"				; CHAR 1
LETTRS 	=	26				; NUMBER OF LETTERS
FIVEC	=	"5"				; CHAR 5 (HIGHEST SYMBOL NUMBER)

; BUILT INS

DEFC 	=	"s"				; SET SYMBOL
EQUALC 	=	"="				; EQUALS
LESSC 	=	"<"				; LESS THAN
GREATC	=	">"				; GREATER THAN
NOTC 	=	"!"				; NOT
ANDC 	=	"^"				; AND
ORC		=	"|"				; OR
ADDC 	=	"+"				; ADD
CONSC 	=	"c"				; CONS
CARC 	=	"a"				; CAR
CDRC 	= 	"r"				; CDR
EVALC 	=	"e"				; EVAL
TESTC   =	"t"				; TEST
PRINTC 	=	"p"				; PRINT
GROUPC	=	"g"				; GROUP

#INCLUDE "stdlib/stdio.s"

		LDA #$02
		STA iomode

        LDA #0      

; S-EXPRESSION POINTER

        STA XPTR
        LDX	#>XSPCE
        STX	XPTR+1

; SCOPE POINTER

        STA SCOPE
        LDX #>SCOPES
        STX SCOPE+1

; SCOPE STACK POINTER

        STA SPPTR
        LDX #>SPSTCK
        STX SPPTR+1

; QUOTE POINTER

		STA QPTR
		LDX #>QPTRS
		STX QPTR+1

; FUNCTIONS POINTER

		STA FNPTR
		LDX #>FNS
		STX FNPTR+1

; MACROS POINTER

		STA MPTR
		LDX #>MACROS
		STX MPTR+1

; RESULT STACK POINTER

		STA RSPTR
		LDX	#>RSTCK
		STX RSPTR+1

; ARGS AND ARG STACK POINTER

		STA ARGPT
		STA ARGSPT

; INPUT POINTER

		STA INPTR

; CLEAR GLOBAL SYMBOL TABLE

		LDY	#SCPSZ
CLGSL	DEY
		STA (SCOPE),Y
		BNE	CLGSL

; SET UP SYMBOL TABLE STACK POINTER

        LDY	#0
        STA (SPPTR),Y
        INY
        LDA #>SCOPES
        STA (SPPTR),Y        

; PARSE AND EXECUTE INPUT BUFFER (REPL)

REPL	LDA #"="
		STA PUTC
		LDA #">"
		STA PUTC
		LDA #" "
		STA PUTC
		
		JSR	NXTIN
		CMP	#0
		BEQ	DONE
		JSR	PARSE

		LDA #$0A
		STA	PUTC

		JSR	TEVAL
		JSR PRINT

		LDA #$0A
		STA	PUTC
	
		JMP REPL

;  FINISH

DONE    EXT

;
;  TEST TYPES (TOP OF STACK)
;  ZERO FLAG 1 IF TRUE, 0 OTHERWISE
;

;  IS NUMBER

ISNUMB	LDA #SNCODE
		STA R0+1
		LDA	#VMSK
		STA R0
		JMP TTYP

;  IS SYMBOL

ISSYMB	JSR ISNIL
		BEQ NOTSYM
		LDA #SNCODE
		STA R0+1
		LDA #0
		STA R0
		JMP TTYP

NOTSYM	LDA #1					; CLEAR Z FLAG
		RTS

;  IS CHARACTER

ISCHAR	LDA #BCCODE
		STA R0+1
		LDA	#VMSK
		STA R0
		JMP TTYP
		
;  IS BUILT IN

ISBILT	LDA #BCCODE
		STA R0+1
		LDA	#0
		STA R0

TTYP	LDY #1
		LDA	(RSPTR),Y
		CMP R0+1
		BNE NOTTYP
		DEY
		LDA (RSPTR),Y
		AND #VMSK
		CMP R0
NOTTYP	RTS

;  IS IN PAGE

INPAGE 	LDY #1
		CMP (RSPTR),Y
		RTS

;  IS QUOTE

ISQUOT	LDA #>QPTRS
		JSR INPAGE
		RTS

;  IS FUNCTION

ISFN	LDA #>FNS
		JSR INPAGE
		RTS

;  IS MACRO

ISM 	LDA #>MACROS
		JSR INPAGE
		RTS

;  IS EXPRESSION

ISSX	LDY	#1
		LDA	(RSPTR),Y
		CMP	#>XSPCE
		BPL	ADTR
		LDA	#1							; IS NOT S-EXPRESSION
		RTS

ADTR	AND	#XMSK
		RTS

; IS NIL

ISNIL	LDY #0
		LDA	(RSPTR),Y
		CMP #NIL
		BNE NOTNIL
		INY
		LDA	(RSPTR),Y
		CMP #SNCODE
NOTNIL	RTS

;
;  PARSING FUNCTIONS
;

; PARSE QUOTE

PQUOTE	JSR NXTIN
		JSR PARSE
		LDY #0
		LDA (RSPTR),Y
		STA (QPTR),Y
		INY
		LDA (RSPTR),Y
		STA (QPTR),Y
		LDA QPTR+1
		STA (RSPTR),Y		
		LDA QPTR
		DEY
		STA (RSPTR),Y		
		INC QPTR
		INC QPTR		
		RTS

; PARSE S-EXPRESSION

PXS		JSR NXTIN
		CMP #CLSSX
		BNE ASX

MKNIL	LDY #0					; MKNIL ALSO GETS CALLED FROM ALL OVER THE PLACE
		LDA #NIL
		STA (RSPTR),Y
		INY
		LDA #SNCODE
		STA (RSPTR),Y
		RTS

ASX		JSR PARSE
		INC RSPTR
		INC RSPTR
		JSR PXS
		JSR MKCONS
		RTS

; PARSE SYMBOL

PSYMB	JSR COMPS

; MAKE A SYMBOL WORD FROM A SYMBOL BYTE

MKSYM	LDY #0
		STA (RSPTR),Y
		LDA #SNCODE
		INY
		STA (RSPTR),Y
		RTS

;  NEXT CHAR IS IN A

PARSE	CMP	#CHAR
		BEQ	PCHAR
		CMP #NUMBR
		BEQ	PNUMBR
		CMP #QUOTE
		BEQ	PQUOTE
		CMP #OPNSX
		BEQ	PXS
		CMP #FDEF
		BEQ	PFUNC
		CMP #MDEF
		BEQ	PMACRO
		JSR	TSTSYM
		BEQ	PSYMB

; OTHERWISE BUILT IN

		LDY	#0
BILTL	CMP BILTC,Y
		BEQ FNDBLT
		INY
		CPY #BILTN
		BNE BILTL
		JMP	DONE 			; NOT FOUND

FNDBLT	TYA
		ASL
		LDY #0
		STA (RSPTR),Y
		INY
		LDA #BCCODE
		STA (RSPTR),Y
		RTS

; PARSE CHAR

PCHAR	JSR	NXTIN
		ORA	#VMSK
		LDY	#0
		STA (RSPTR),Y
		INY
		LDA	#BCCODE
		STA (RSPTR),Y
		RTS

; PARSE NUMBER 

PNUMBR	JSR	NXTIN
		SEC
		SBC	#ZEROC
		ORA #VMSK
		LDY	#0
		STA (RSPTR),Y
		INY
		LDA	#SNCODE
		STA (RSPTR),Y
		RTS

; PARSE FUNCTION

PFUNC	LDY #0
		LDA FNPTR
		STA (RSPTR),Y
		LDA FNPTR+1
		INY
		STA (RSPTR),Y
		LDA FNPTR
		CLC
		ADC #PROCSZ
		STA FNPTR
		JMP PPROC

; PARSE MACRO

PMACRO	LDY #0
		LDA MPTR
		STA (RSPTR),Y
		LDA MPTR+1
		INY
		STA (RSPTR),Y
		LDA MPTR
		CLC
		ADC #PROCSZ
		STA MPTR

; PARSE COMMON PARTS

PPROC	JSR NXTIN					; SKIP [
		INC RSPTR
		INC RSPTR
		LDY #0
		LDA (SPPTR),Y
		STA (RSPTR),Y
		INY
		LDA (SPPTR),Y
		STA (RSPTR),Y
		INC RSPTR
		INC RSPTR
		LDY #0
		LDA ARGPT
		STA (RSPTR),Y
		INC RSPTR
		
PROCL	JSR NXTIN
		CMP #CLSARG
		BEQ ENDA
		JSR COMPS
		LDY ARGPT
		STA ARGS,Y
		INC ARGPT
		JMP PROCL

ENDA	LDY ARGPT
		LDA #ARGEND
		STA ARGS,Y
		INC ARGPT

		JSR NXTIN
		JSR PARSE

		LDA RSPTR
		SEC
		SBC #PROCSZ
		STA RSPTR
		JSR CPYR0
		INC RSPTR
		INC RSPTR

		LDY #0
PROCPY	LDA (RSPTR),Y
		STA (R0),Y
		INY
		CPY #PROCSZ
		BNE PROCPY
		
		DEC RSPTR
		DEC RSPTR
		
		RTS


;  BUILT INS

BILTC	
.BYTE DEFC
.BYTE EQUALC
.BYTE LESSC
.BYTE GREATC
.BYTE NOTC
.BYTE ANDC
.BYTE ORC
.BYTE ADDC
.BYTE CONSC
.BYTE CARC
.BYTE CDRC
.BYTE EVALC
.BYTE TESTC
.BYTE GROUPC
.BYTE PRINTC

BILTN =	15

BILTE
.WORD EDEF
.WORD EEQUAL
.WORD ELESS
.WORD EGREAT
.WORD ENOT
.WORD EAND
.WORD EORW
.WORD EADD
.WORD ECONS
.WORD ECAR
.WORD ECADR
.WORD EEVAL
.WORD ETEST
.WORD EGROUP
.WORD EPRINT

;
;  BOOLEAN - NIL IS FALSE, ALL ELSE IS TRUE
;

; DEFINE SYMBOL

EDEF	LDX #2
		JSR FCHARG
		INC RSPTR
		INC RSPTR		
		LDX #4
		JSR FCHARG
		JSR EVALR
		JSR SETSYM
		JSR MKNIL
		RTS

SETSYM	JSR CPYR0
		DEC RSPTR
		DEC RSPTR
		LDY #$1
		LDA (SPPTR),Y
		STA R1+1
		DEY
		LDA (SPPTR),Y
		STA R1
		LDA (RSPTR),Y
		TAY
		LDA R0
		STA (R1),Y
		INY
		LDA R0+1
		STA (R1),Y
		RTS

		
; CHECK FOR EQUALITY
; NUMBERS ONLY

EEQUAL	JSR GET2N
		CMP R0
		BNE SETNEQ
		JSR MKONE
		RTS

SETNEQ 	JSR MKNIL
		RTS

; CHECK FOR LESS THAN

ELESS	JSR GET2N
		CMP R0
		BEQ SETNLT
		BPL SETNLT
		JSR MKONE
		RTS

SETNLT 	JSR MKNIL
		RTS

; CHECK FOR GREATER THAN

EGREAT  JSR GET2N
		CMP R0
		BEQ SETNGT
		BMI SETNGT
		JSR MKONE
		RTS

SETNGT 	JSR MKNIL
		RTS

; NEGATION

ENOT	JSR MONOP
		JSR ISNIL
		BEQ NSETT
		JSR MKNIL
		RTS

NSETT	JSR MKONE
		RTS

; AND

EAND	JSR BINOP
		JSR ISNIL
		BEQ ASETF1
		DEC RSPTR
		DEC RSPTR
		JSR ISNIL
		BEQ ASETF2 
		JSR MKONE
		RTS

ASETF1	DEC RSPTR
		DEC RSPTR
ASETF2	JSR MKNIL
		RTS

; OR

EORW 	JSR BINOP
		JSR ISNIL
		BNE ODEC
		DEC RSPTR
		DEC RSPTR
		JSR ISNIL
		BNE OSETT
		RTS

ODEC	DEC RSPTR
		DEC RSPTR
OSETT	JSR MKONE
		RTS

; ADD NUMBERS

EADD	JSR GET2N
		CLC
		ADC R0
		ORA #VMSK
		LDY #0
		STA (RSPTR),Y
		INY
		LDA #SNCODE
		STA (RSPTR),Y
		RTS


; CONS TO A LIST

ECONS	JSR BINOP
		JSR MKCONS
		RTS

; FIRST LIST ELEMENT

ECAR	JSR MONOP
		JSR CPYR0
		JSR CPYA0R
		RTS

; REST OF LIST

ECADR	JSR MONOP
CCADR	JSR CPYR0
		INC R0
		INC R0
		JSR CPYA0R
		RTS

; EVAL

EEVAL 	JSR MONOP
		JSR ISQUOT
		BNE DOEVAL
		JSR CPYR0
		JSR CPYA0R
DOEVAL	JMP	EVALR

; BRANCHING PRIMITIVE
; EVEN SIZE LIST
; TEST, EXPRESSION PAIRS
; EVALUATE FIRST EXPRESSION WHERE TEST IS TRUE
; OTHERWISE NIL

ETEST	LDX #2
		JSR FCHARG
		BEQ ETNFND
		JSR EVALR
		JSR ISNIL
		BNE ETFND
		LDX #2
		JSR FCHARG
		JMP ETEST

ETFND	LDX #2
		JSR FCHARG
		JSR EVALR
		RTS

ETNFND 	JSR MKNIL
		RTS
		
;  GROUP - EVAL EVERY CAR IN A LIST

EGROUP 	LDX #2
		JSR FCHARG
		BEQ EGDON
		JSR EVALR
		JMP EGROUP

EGDON	RTS

;  PRINT

EPRINT	JSR MONOP
		JSR PRINT
		JSR MKNIL
		RTS

;
; UTILITY FUNCTIONS
;

; GET 2 NUMERIC ARGUMENTS
; PUT THEM IN R0 AND A

GET2N	JSR	BINOP
		LDY #0
		LDA (RSPTR),Y
		AND #$FF ^ VMSK
		STA R0
		DEC RSPTR
		DEC RSPTR
		LDA (RSPTR),Y
		AND #$FF ^ VMSK
		RTS

;  DEBUGGER

PDBG 	JSR HEXO
		LDA	RSPTR
		JSR HEXO
		LDA RSPTR+1
		JSR HEXO

		LDY #0
DBGL	LDA RSTCK,Y
		JSR HEXO
		INY
		CPY RSPTR
		BMI DBGL
		BEQ DBGL

		LDA RSTCK,Y
		JSR HEXO

		LDA #$0A
		STA PUTC
		RTS

;  FORMAT HEX

HEXO 	PHA

		ROR
		ROR
		ROR
		ROR

		JSR NIBL
		PLA
		JSR NIBL
		LDA #" "
		STA PUTC
		RTS

NIBL 	AND #$0F
		CMP #$0A
		BMI HBLL
		CLC
		ADC #"A" - 10
		STA PUTC
		RTS

HBLL	CLC
		ADC #"0"
		STA PUTC
		RTS

; GET ARGUMENT FOR MONADIC OP

MONOP 	LDX #2
		JSR FCHARG
		JSR EVALR
		RTS

; GET ARGUMENTS FOR BINARY OP

BINOP	JSR MONOP
		INC RSPTR
		INC RSPTR
		LDX #4
		JSR FCHARG
		JSR EVALR
		RTS

; FETCH AN ARGUMENT	
; SX POINTER IS X REGISTER BYTES DOWN THE STACK

FCHARG	STX	R1
		LDA RSPTR
		SEC
		SBC R1
		STA RSPTR 
		JSR ISNIL
		BEQ FDONE
		JSR CCADR
		JSR ISNIL
		BEQ FDONE
		JSR CPYR0
		LDA RSPTR
		CLC
		ADC R1
		STA RSPTR
		JSR CPYA0R
		LDA #1				; CLEAR ZERO FLAG
		RTS

FDONE	LDA RSPTR
		CLC
		ADC R1
		STA RSPTR
		LDA #0				; SET ZERO FLAG
		RTS		

; DUPLICATE TOP OF STACK

DUP 	JSR CPYR0
		INC RSPTR
		INC RSPTR
		JSR CPY0R
		RTS

; INVERSE OF DUPLICATE TOP OF STACK

DEDUP 	JSR CPYR0
		DEC RSPTR
		DEC RSPTR
		JSR CPY0R
		RTS

; COMPUTE A SYMBOL BYTE

COMPS	CMP #FIVEC + 1
		BMI PSN
		SEC
		SBC #AC
		BPL PSD
PSN		SEC
		SBC #ZSDLTA
PSD		ASL
		RTS

; SET ZERO FLAG IF CHAR IS A SYMBOL

TSTSYM	CMP #ZEROC
		BEQ ETSYM
		BMI ETSYM
		CMP #FIVEC
		BEQ ETSYM
		BMI SETZ
		CMP #AC
		BEQ ETSYM
		BMI ETSYM
		CMP #ZC
		BEQ ETSYM
		BPL ETSYM
SETZ	LDY #0 				; SET EQUAL FLAG
ETSYM	RTS


; NEXT INPUT CHARACTER

NXTIN	LDY	INPTR
		LDA INPUT,Y
		INC INPTR
		STA PUTC
		RTS

; OUTPUT A CHARACTER

OUT 	STA PUTC
		RTS

;  COPY RESULT STACK TO RO

CPYR0	LDY	#0
		LDA	(RSPTR),Y
		STA R0
		INY
		LDA	(RSPTR),Y
		STA R0+1
		RTS

;  COPY R0 TO RESULT STACK

CPY0R 	LDY #0
		LDA R0
		STA (RSPTR),Y
		INY
		LDA R0+1
		STA (RSPTR),Y
		RTS

;  COPY DATA POINTED TO BY R0 TO RESULT STACK

CPYA0R	LDY	#0
		LDA (R0),Y
		STA (RSPTR),Y
		INY
		LDA (R0),Y
		STA (RSPTR),Y
		RTS

;  COPY RESULT STACK TO LOCATION POINTED TO BY R0

CPYRA0	LDY	#0
		LDA (RSPTR),Y
		STA (R0),Y
		INY
		LDA (RSPTR),Y
		STA (R0),Y
		RTS

; CREATE A CONS CELL
; STACK HOLDS CAR AND CDR

MKCONS	DEC RSPTR
		DEC RSPTR
		LDY #0
CONSL	LDA (RSPTR),Y
		STA (XPTR),Y
		INY
		CPY #CELLSZ
		BNE	CONSL
		
		LDY #0
		LDA XPTR
		STA (RSPTR),Y
		INY
		LDA XPTR+1
		STA (RSPTR),Y

		LDA XPTR
		CLC
		ADC #CELLSZ
		STA XPTR
		BCC MKCD
		INC XPTR+1

MKCD	RTS

;  PUT A NUMERIC ONE ON TOP OF THE STACK

MKONE	LDY #0
		LDA #ONE
		STA (RSPTR),Y
		INY
		LDA #SNCODE
		STA (RSPTR),Y
		RTS

;
; EVAL ROUTINES
;

; EVAL S-EXPRESSION

ESX 	JSR CPYR0
		INC RSPTR
		INC RSPTR
		JSR CPYA0R
		JSR ISSYMB
		BNE ENSYMB
		JSR ESYMB
ENSYMB	JSR ISBILT
		BNE ENBILT
		JSR EBILT
		JMP CLNUP

ENBILT	JSR ISFN
		BNE ENFN
		JSR EFN
		JMP CLNUP
		
ENFN	JSR ISM
		BNE ENM
		JSR EM

CLNUP	JSR DEDUP
		RTS

ENM		EXT

; TOP LEVEL EVAL

TEVAL	JSR	ISQUOT
		BNE EVALR
		JSR CPYR0
		JSR CPYA0R
		RTS

; RECURSIVELY EVALUATE THE EXPRESSION ON THE TOP OF THE STACK

EVALR 	JSR ISNIL
		BEQ EDONE
		JSR ISCHAR
		BEQ EDONE
		JSR ISNUMB
		BEQ EDONE
		JSR ISSYMB
		BEQ ESYMB
		JSR ISBILT
		BEQ EDONE
		JSR ISQUOT
		BEQ EDONE
		JSR ISFN
		BEQ EDONE
		JSR ISM
		BEQ EDONE
		JSR ISSX
		BEQ ESX
		EXT					; NOTHING FOUND

; SYMBOL

ESYMB	LDY	#1
		LDA (SPPTR),Y
		STA R0+1
		DEY
		LDA (SPPTR),Y
		STA R0
		LDA (RSPTR),Y
		TAY
		LDA (R0),Y
		STA R1
		INY
		LDA (R0),Y
		STA R1+1
		LDY #0
		LDA R1
		STA (RSPTR),Y
		INY
		LDA R1+1
		STA (RSPTR),Y
		JSR ISSYMB
		BNE SYDONE
		JSR ESYMB
SYDONE	RTS

; DO NOTHING

EDONE	RTS

; BUILT IN

EBILT	LDY #0
		LDA (RSPTR),Y
		TAX
		LDA BILTE,X
		STA R0
		INX
		LDA BILTE,X
		STA R0+1
		JMP (R0)

; FUNCTION

EFN		LDA #1
		BNE EPROC

; MACRO

EM 		LDA #0

; FUNCTION AND MACRO

EPROC	PHP					; HANG ONTO FN/MACRO FLAG

; ALLOCATE AND FILL SYMBOL TABLE

		LDA #$10
		JSR PDBG

		LDA SCOPE
		CLC
		ADC #SCPSZ
		STA SCOPE
		STA R2
		BCC CSCP
		INC SCOPE+1

CSCP	LDA SCOPE+1
		STA R2+1

FILL	LDY #PROCSY
		JSR CPYR0
		LDA (R0),Y
		STA R1
		INY
		LDA (R0),Y
		STA R1+1
		LDY #0
FILLL	LDA (R1),Y
		STA (R2),Y
		INY
		CPY #SCPSZ 
		BNE FILLL

; FILL IN ARGUMENTS
		
		LDA #$11
		JSR PDBG

		LDY #PROCAL
		LDA (R0),Y
		LDY ARGSPT
		INC ARGSPT
		STA ARGSP,Y

		INC RSPTR
		INC RSPTR
		LDY #1
		LDA #SNCODE
		STA (RSPTR),Y

		LDA #$12
		JSR PDBG

ARGCL	LDX ARGSPT
		LDA ARGSP,X
		INC ARGSP,X
		TAY
		LDA ARGS,Y
		STA (RSPTR),Y
		INC RSPTR   
		INC RSPTR

		LDA #$13
		JSR PDBG

		LDX #6
		JSR FCHARG
		BEQ FNDONE

		LDA #$14
		JSR PDBG

		PLP
		PHP
		BEQ FAM
		JSR	EVALR
FAM		
		LDA #$15
		JSR PDBG

		JSR SETSYM	
		JMP ARGCL

FNDONE	PLP
		
		LDA #$16
		JSR PDBG

		DEC RSPTR
		DEC RSPTR
		DEC RSPTR
		DEC RSPTR

		JSR CPYR0
		LDY #PROCSX
		LDA R0
		STA (RSPTR),Y
		LDA R0+1
		INY
		STA (RSPTR),Y

;		LDA #$15
;		JSR PDBG
;		LDY #1
;		INC SPPTR
;		INC SPPTR
;		LDA SCOPE+1
;		STA R2+1
;		STA (SPPTR),Y
;		DEY
;		LDA SCOPE
;		STA R2
;		STA (SPPTR),Y

		JSR EVALR

		LDA #$17
		JSR PDBG

		RTS
;
; PRINT ROUTINES
;

; PRINT CHARACTER

PNCHAR 	LDY #0
		LDA (RSPTR),Y
		AND #$FF ^ VMSK
		JSR OUT
		RTS

; PRINT NUMBER

PNNUMB 	PHA
		LDA #NUMBR
		JSR OUT
		PLA
		LDY #0
		LDA (RSPTR),Y
		AND #$FF ^ VMSK

		CMP #100
		BMI TENSQ
		CLC
		SBC #100
		PHA
		LDA #ONEC
		JSR OUT
		PLA

TENSQ	CMP #10
		BMI ONES

		LDX #ZEROC
		SEC
TENSL	INX
		SBC #10
		CMP #9
		BPL TENSL
		PHA
		TXA
		JSR OUT
		PLA

ONES	CLC
		ADC	#ZEROC
		JSR OUT
		RTS

; PRINT QUOTE 

PNQUOT	LDA	#QUOTE
		JSR OUT
		JSR CPYR0
		JSR CPYA0R
		JSR PRINT
		RTS

; PRINT BUILT IN

PNBILT	LDY #0
		LDA (RSPTR),Y
		CLC
		ROR
		TAY
		LDA BILTC,Y
		JSR OUT
		RTS

; PRINT NIL

PNNIL	LDA	#OPNSX
		JSR OUT
		LDA #CLSSX
		JSR OUT
		RTS

; PRINT THE EXPRESSION ON THE TOP OF THE STACK

PRINT 	JSR ISCHAR
		BEQ PNCHAR
		JSR ISNUMB
		BEQ PNNUMB
		JSR ISQUOT
		BEQ PNQUOT
		JSR ISBILT
		BEQ PNBILT
		JSR ISNIL
		BEQ PNNIL
		JSR ISSX
		BEQ PNSX
		JSR ISSYMB
		BEQ PNSYMB
		JSR ISFN
		BEQ PNFN
		JSR ISM
		BEQ PNM
		EXT							; NOT FOUND

; PRINT S-EXPRESSION

PNSX 	JSR ISNIL
		BNE PNNNIL
		JSR PNNIL
		RTS
			
PNNNIL	LDA	#OPNSX
		JSR OUT
PNSXL	JSR CPYR0
		INC RSPTR
		INC RSPTR
		JSR CPYA0R
		JSR PRINT
		DEC RSPTR
		DEC RSPTR
		JSR CPYR0
		INC R0
		INC R0
		JSR CPYA0R
		JSR ISNIL
		BNE PNSXL

		LDA #CLSSX
		JSR OUT
		RTS

; PRINT SYMBOL

PNSYMB	LDY #0
		LDA (RSPTR),Y

; PRINT SYMBOL IN A

LPNSY	CLC
		ROR
		CMP #LETTRS
		BPL NSYMB
		ADC #AC
		JSR OUT
		RTS

NSYMB	CLC
		ADC #ZSDLTA
		JSR OUT
		RTS

; PRINT FUNCTION

PNFN	LDA #FDEF
		JSR OUT
		JMP PNPROC	

; PRINT MACRO

PNM 	LDA #MDEF
		JSR OUT

; PRINT PROCEDURE (COMMON TO FUNCTION AND MACRO)

PNPROC 	LDA #OPNARG
		JSR OUT
		JSR CPYR0
		LDY #PROCAL
		LDA (R0),Y
		TAX
ARGPL	LDA ARGS,X
		CMP #ARGEND
		BEQ ARDN
		JSR LPNSY
		INX
		JMP ARGPL

ARDN 	LDA #CLSARG
		JSR OUT

		JSR CPYR0
		INC RSPTR
		INC RSPTR
		LDY #PROCSX
		LDX #0
		LDA (R0),Y
		STA (RSPTR,X)
		INY
		INC RSPTR
		LDA (R0),Y
		STA (RSPTR,X)
		DEC RSPTR
		JSR PRINT
		DEC RSPTR
		DEC RSPTR
		RTS
		
INPUT
