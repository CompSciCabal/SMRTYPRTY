;    ATTOLISP.ASM
;
;    6502 ASSEMBLER IMPLEMENTATION OF A LISP TOO SMALL TO USE
;
;
R0   	=	$02             ; REGISTERS
R0H     =   $03
R1   	=	$04
R1H     =   $05
R2   	=	$06
R2H     =   $07
R3   	=	$08
R3H     =   $09

XPTR	=	$0A				; S-EXPRESSION SPACE POINTER
XPTRH	=	$0B
SCOPE 	=	$0C             ; CURRENT SCOPE POINTER
SCOPEH	=	$0D
RSPTR   =   $0E             ; RESULT STACK POINTER
RSPTRH	=	$0F
QPTR	=	$10				; QUOTE SPACE POINTER
QPTRH	=	$11
FNPTR	=	$12				; FUNCTION SPACE POINTER
FNPTRH	=	$13
ARGPT	=	$14				; ARGS POINTER
ARGPTH	=	$15
MPTR	=	$16				; MACRO SPACE POINTER
MPTRH	=	$17
INPTR	=	$18				; INPUT POINTER
INPTRH	=	$19
OUPTR	=	$1A				; OUTPUT POINTER
OUPTRH	=	$1B
SPPTR	=	$1C				; SCOPE STACK POINTER
SSPTRH	=	$1E

ENDPGE  =   $FF             ; END OF ANY PAGE

; STACK POINTER USES PAGE 1

XSPCE	=	$0200			; S-EXPRESSION SPACE
SCOPES  =   $3C00			; SCOPE SPACE
SPSTCK	=	$F400			; SCOPE POINTER STACK
RSTCK 	=	$F500			; RESULT STACK 
QPTRS	=	$F600			; QUOTE POINTERS
FNS		=	$F700			; FUNCTIONS
ARGS	=	$F800			; ARGS
MACROS	=	$F900			; MACRO SPACE
INPUT   =   $FA00		    ; INPUT
OUTPUT 	=   $FB00		    ; OUPUT

SCPSZ   =   64              ; SIZE OF SCOPE 2 * (26 LETTERS + 6 NUMBERS)
CELLSZ	=	4				; SIZE OF CONS CELL
PROCSZ	=	5				; SIZE OF PROC (FN, MACRO)
PROCSY  = 	0				; OFFSET OF PROC SYMBOL TABLE POINTER
PROCAL	= 	2				; OFFSET OF PROC ARGUMENT LIST POINTER
PROCSX	= 	3				; OFFSET OF PROC S-EXPRESSION POINTER

VMSK	=	$80				; VALUES (CHAR AND INT) MASK
VMSKC	=	$7F				; COMPLEMENT
SYMMSK	=	$D0				; SYMBOL MASK
SNCODE	=	$00				; SYMBOL AND NUMBER (AND OTHER) CODE
BCCODE	=	$01				; BUILT INS AND CHAR CODE
ADMSK	=	$FE 			; ADDRESS MASK
XMSK	=	$80				; S-EXPRESSION MASK
XMSKC	=	$7F				; COMPLEMENT
NIL		=	$40				; NIL LOW ORDER (SNCODE, NIL)
ARGEND	=	$41				; END OF ARGUMENTS FLAG

LPAREN	=	$28				; ( OPEN S-EXPRESSION
RPAREN	=	$29				; ) CLOSE S-EXPRESSION
LBRKT	=	$5B				; [ OPEN ARGUMENT LIST
RBRKT	=	$5D				; ] CLOSE ARGUMENT LIST
FDEF	=	$66				; F FUNCTION
MDEF	=	$6D				; M MACRO
QUOTE 	=	$27				; ' QUOTE
CHAR 	=	$22				; " CHARACTER
NUMBR 	=	$23				; # NUMBER
AC 		=	$41				; A (LOWEST SYMBOL LETTER)
ACM		=	$40				; ONE LESS THAN THAT
ZC 		=	$5A				; Z (HIGHEST SYMBOL LETTER)
ZCP		=	$5B				; ONE MORE THAN THAT
ZEROC	=	$30				; CHAR 0
ZEROCM	=	$2F				; ONE LESS THAN THAT
ZSDLTA	=	$4A				; TRANSLATE CHAR 0 TO SYMBOL VALUE
ONEC	=	$31				; CHAR 1
LETTRS 	=	26				; NUMBER OF LETTERS
FIVEC	=	$35				; CHAR 5 (HIGHEST SYMBOL NUMBER)
SIXC	=	$36				; ONE MORE THAN THAT

; BUILT INS

DEF 	=	$64				; D DEFINE SYMBOL
EQUAL 	=	$3D				; = EQUALS
LESS 	=	$3C				; < LESS THAN
ADD 	=	$2B				; + ADD
CONS 	=	$63				; C CONS
CAR 	=	$61				; A CAR
CDR 	= 	$72				; R CDR
EVAL 	=	$65				; E EVAL

*       =   $FC00

        LDA #0      

; S-EXPRESSION POINTER

        STA *XPTR
        LDX	#>XSPCE
        STX	*XPTRH

; SCOPE POINTER

        STA *SCOPE
        LDX #>SCOPES
        STX *SCOPEH

; SCOPE STACK POINTER

        STA *SPPTR
        LDX #>SPSTCK
        STX *SSPTRH

; RESULT STACK POINTER

		STA *RSPTR
		LDX	#>RSTCK
		STX *RSPTRH

; QUOTE POINTER

		STA *QPTR
		LDX #>QPTRS
		STX *QPTRH

; FUNCTIONS POINTER

		STA *FNPTR
		LDX #>FNS
		STX *FNPTRH

; ARGS POINTER

		STA *ARGPT
		LDX #>ARGS
		STX *ARGPTH

; MACROS POINTER

		STA *MPTR
		LDX #>MACROS
		STX *MPTRH

; INPUT POINTER

		STA *INPTR
		LDX #>INPUT
		STX *INPTRH

; OUTPUT POINTER

		STA *OUPTR
		LDX #>OUTPUT
		STX *OUPTRH


; CLEAR GLOBAL SYMBOL TABLE

		LDY	#SCPSZ
CLGSL	DEY
		STA (SCOPE),Y
		BNE	CLGSL

; SET UP SYMBOL TABLE STACK POINTER

        LDY	#0
        STA (SPPTR),Y
        INY
        LDA (SCOPE),Y
        STA (SPPTR),Y        

; CLEAR OUTPUT

		LDA	#$20			; SPACE
		LDY	#0
CLOUTL	DEY
		STA (OUPTR),Y
		BNE	CLOUTL

;  DEBUGGING DELAY

		LDY	#15
DELAY	DEY
		BNE	DELAY

; PARSE AND EXECUTE INPUT BUFFER (REPL)

REPL	JSR	NXTIN
		CMP	#0
		BEQ	DONE
		JSR	PARSE
		JSR	EVAL
		JSR	PRINT
		JMP REPL

;  FINISH

DONE    BRK

;  TEST TYPES (TOP OF STACK)
;  ZERO FLAG 1 IF TRUE, 0 OTHERWISE

;  IS NUMBER

ISNUMB	LDA #SNCODE
		STA *R0
		LDA	#VMSK
		STA *R0H
		JMP TTYP

;  IS SYMBOL

ISSYMB	JSR ISNIL
		LDA #SNCODE
		BEQ NOTSYM
		STA *R0
		LDA #0
		STA *R0H
		JMP TTYP

NOTSYM	CMP #BCCODE				; CLEAR Z FLAG
		RTS

;  IS CHARACTER

ISCHAR	LDA #BCCODE
		STA *R0
		LDA	#VMSK
		STA *R0H
		JMP TTYP
		
;  IS BUILT IN

ISBILT	LDA #BCCODE
		STA *R0
		LDA	#0
		STA *R0H

TTYP	LDY #1
		LDA	(RSPTR),Y
		CMP *R0
		BNE NOTTYP
		DEY
		LDA (RSPTR),Y
		AND #VMSK
		CMP *R0H
NOTTYP	RTS

;  IS QUOTE

ISQUOT	LDY #1
		LDA	(RSPTR),Y
		CMP #QPTRS
		RTS

;  IS FUNCTION

ISFN	LDY #1
		LDA	(RSPTR),Y
		CMP #FNS
		RTS

;  IS MACRO

ISMM	LDY #1
		LDA	(RSPTR),Y
		CMP #MACROS
		RTS

;  IS EXPRESSION

ISSX	LDY	#1
		LDA	(RSPTR),Y
		AND	#ADMSK
		BNE	ADTR
		AND	#0
		RTS

ADTR	AND	XMSK
		RTS

; IS NIL

ISNIL	LDY #1
		LDA	(RSPTR),Y
		CMP #SNCODE
		BNE NOTNIL
		DEY
		LDA	(RSPTR),Y
		CMP #NIL
NOTNIL	RTS
		

;  DON'T THINK WE NEED THIS

;  TRUE AND FALSE SET AND CLEAR ZERO FLAG

TRUE	PHA
		LDA	#0
		CMP	#0
		PLA
		RTS

FALSE	PHA
		LDA	#0
		CMP	#1
		PLA
		RTS

;

; PARSE CHAR

PCHAR	JSR	NXTIN
		ORA	#VMSK
		LDY	#0
		STA (RSPTR),Y
		INY
		LDA	#BCCODE
		STA (RSPTR),Y
		RTS

; PARSE NUMBER 

PNUMBR	JSR	NXTIN
		SBC	#ZEROC
		ORA #VMSK
		LDY	#0
		STA (RSPTR),Y
		INY
		LDA	#SNCODE
		STA (RSPTR),Y
		RTS

; PARSE QUOTE

PQUOTE	JSR NXTIN
		JSR PARSE
		LDY 0
		LDA (RSPTR),Y
		STA (QPTR),Y
		INY
		LDA (RSPTR),Y
		STA (QPTR),Y
		LDA *QPTR
		STA *RSPTR		
		LDA *QPTRH
		STA *RSPTRH
		INC *QPTR
		INC *QPTR		
		RTS

; PARSE S-EXPRESSION

PXS		JSR NXTIN
		CMP #RPAREN
		BNE ACROSS

		LDY #0
		LDA #NIL
		STA (RSPTR),Y
		INY
		LDA #SNCODE
		STA (RSPTR),Y
		RTS

ACROSS	JSR PARSE
		INC RSPTR
		INC RSPTR
		JSR PXS
		JSR CONS
		RTS

; PARSE SYMBOL

PSYMB	JSR COMPS

; MAKE A SYMBOL WORD FROM A SYMBOL BYTE

MKSYM	LDY #1
		STA (RSPTR),Y
		LDA #SNCODE
		DEY
		STA (RSPTR),Y
		RTS

;  NEXT CHAR IS IN A

PARSE	CMP	#CHAR
		BEQ	PCHAR
		CMP #NUMBR
		BEQ	PNUMBR
		CMP #QUOTE
		BEQ	PQUOTE
		CMP #LPAREN
		BEQ	PXS
		CMP #FDEF
		BEQ	PFUNC
		CMP #MDEF
		BEQ	PMACRO
		JSR	TSTSYM
		BEQ	PSYMB

; OTHERWISE BUILT IN

		LDY	#0
BILTL	CMP BILTC,Y
		BEQ FNDBLT
		INY
		CPY #BILTN
		BNE BILTL
		JMP	DONE 			; NOT FOUND

FNDBLT	TYA
		ASL A
		LDY #0
		STA (RSPTR),Y
		INY
		LDA #BCCODE
		STA (RSPTR),Y
		RTS
		
PFUNC	LDY #0
		LDA *FNPTR
		STA (RSPTR),Y
		LDA *FNPTRH
		INY
		STA (RSPTR),Y
		LDA *FNPTR
		CLC
		ADC #PROCSZ
		STA *FNPTR
		JMP PPROC

PMACRO	LDY #0
		LDA *MPTR
		STA (RSPTR),Y
		LDA *MPTRH
		INY
		STA (RSPTR),Y
		LDA *MPTR
		CLC
		ADC #PROCSZ
		STA *MPTR

PPROC	JSR NXTIN					; SKIP [
		INC RSPTR
		INC RSPTR
		LDY *0
		LDA (SPPTR),Y
		STA (RSPTR),Y
		INY
		LDA (SPPTR),Y
		STA (RSPTR),Y
		INC RSPTR
		INC RSPTR
		LDY #0
		LDA ARGPT
		STA (RSPTR),Y
		
PROCL	JSR NXTIN
		CMP RBRKT
		BEQ ENDA
		JSR COMPS
		LDY #0
		STA (ARGPT),Y
		INC ARGPT
		JMP PROCL

ENDA	LDY #0
		LDA #ARGEND
		STA (ARGPT),Y
		INC ARGPT

		INC RSPTR
		INC RSPTR
		JSR PARSE

		CLC
		LDA *RSPTR
		SBC #PROCSZ
		STA *RSPTR
		JSR CPYS0
		INC RSPTR
		INC RSPTR

		LDY #PROCSZ
PROCPY	DEY
		LDA (RSPTR),Y
		STA (R0),Y
		BNE PROCPY
		
		RTS


;  BUILT INS

BILTC	
.BYTE DEF
.BYTE EQUAL
.BYTE LESS
.BYTE ADD
.BYTE CONS
.BYTE CAR
.BYTE CDR
.BYTE EVAL

BILTN =	8

BILTE
.WORD EDEF
.WORD EEQUAL
.WORD ELESS
.WORD EADD
.WORD ECONS
.WORD ECAR
.WORD ECDR
.WORD EEVAL

EDEF	BRK
EEQUAL	BRK
ELESS	BRK
EADD	BRK
ECONS	BRK
ECAR	BRK
ECDR	BRK
EEVAL	BRK

; COMPUTE A SYMBOL BYTE

COMPS	CMP #SIXC
		BMI PSN
		CLC
		SBC #AC
		BPL PSD
PSN		CLC
		SBC #ZSDLTA
PSD		ASL A
		RTS

; SET ZERO FLAG IF CHAR IS A SYMBOL

TSTSYM	CMP #ZEROC
		BEQ ETSYM
		BMI ETSYM
		CMP #FIVEC
		BEQ ETSYM
		BMI SETZ
		CMP AC
		BEQ ETSYM
		BMI ETSYM
		CMP ZC
		BEQ ETSYM
		BPL ETSYM
SETZ	STA R0 				; SET ZERO FLAG
		CMP R0
ETSYM	RTS


; NEXT INPUT CHARACTER

NXTIN	LDY	#0
		LDA (INPTR),Y
		INC *INPTR
		RTS

OUT 	LDY #0
		STA (OUPTR),Y
		INC *OUPTR
		RTS

;  COPY STACK TO RO

CPYS0	LDY	#0
		LDA	(RSPTR),Y
		STA *R0
		INY
		LDA	(RSPTR),Y
		STA *R0H
		RTS

;  COPY DATA POINTED TO BY R0 TO STACK

CPYA0S	LDY	#0
		LDA (R0),Y
		STA (RSPTR),Y
		INY
		LDA (R0),Y
		STA (RSPTR),Y
		RTS

;  COPY STACK TO LOCATION POINTED TO BY R0

CPYSA0	LDY	#0
		LDA (RSPTR),Y
		STA (R0),Y
		INY
		LDA (RSPTR),Y
		STA (R0),Y
		RTS

CONS	DEC RSPTR
		DEC RSPTR
		LDY #CELLSZ
CONSL	DEY
		LDA (RSPTR),Y
		STA (XPTR),Y
		BNE	CONSL
		
		LDA *XPTR
		STA (RSPTR),Y
		INY
		LDA *XPTRH
		STA (RSPTR),Y

		LDA *XPTR
		ADC #CELLSZ
		STA *XPTR

		RTS

; TOP LEVEL EVAL

EVAL 	JSR	ISQUOT
		BNE EVALR
		JSR CPYS0
		JSR CPYA0S

; RECURIVELY EVALUATE THE EXPRESSION ON THE TOP OF THE STACK

EVALR 	JSR ISCHAR
		BEQ EDONE
		JSR ISNUMB
		BEQ EDONE
		JSR ISSYMB
		BEQ ESYMB
		JSR ISBILT
		BEQ EBILT
		JSR ISQUOT
		BEQ EDONE
		JSR ISFN
		BEQ EFN
		JSR ISMACR
		BEQ EMACRO

; S-EXPRESSION

		BRK

; SYMBOL

ESYMB	BRK

; BUILT IN

EBILT	BRK

EFN		BRK

EMACRO	BRK

; DO NOTHING

EDONE	RTS




; PRINT THE EXPRESSION ON THE TOP OF THE STACK

PRINT 	JSR ISCHAR
		BEQ PNCHAR
		JSR ISNUMB
		BEQ PNNUMB
		JSR ISQUOT
		BEQ PNQUOT
		JSR ISBILT
		BEQ PNBILT
		JSR ISNIL
		BEQ PNNIL
		JSR ISSX
		BEQ PNSX
		JSR ISSYMB
		BEQ PSYMB
		JSR ISFN
		BEQ PFN
		JSR ISM
		BEQ PM
		BRK							; NOT FOUND

PNCHAR 	LDY #0
		LDA (RSPTR),Y
		AND #VMSKC
		JSR OUT
		RTS

PNNUMB 	LDY #0
		LDA (RSPTR),Y
		AND #VMSKC

		CMP #100
		BMI TENSQ
		CLC
		SBC #100
		PHA
		LDA #ONEC
		JSR OUT
		PLA

TENSQ	CMP #10
		BMI ONES

		LDX #ZEROC
		CLC
TENSL	INX
		SBC #10
		CMP #9
		BPL TENSL
		PHA
		TXA
		JSR OUT
		PLA

ONES	CLC
		ADC	#ZEROC
		JSR OUT
		RTS

; PRINT QUOTE 

PNQUOT	LDA	#QUOTE
		JSR OUT
		JSR CPYS0
		JSR CPYA0S
		JSR PRINT
		RTS

; PRINT BUILT IN

PNBILT	LDY #0
		LDA (RSPTR),Y
		ROR A
		TAY
		LDA BILTC,Y
		JSR OUT
		RTS

; PRINT NIL

PNNIL	LDA	#LPAREN
		JSR OUT
		LDA #RPAREN
		JSR OUT
		RTS

; PRINT S-EXPRESSION

PNSX	LDA	#LPAREN
		JSR OUT
PNSXL	JSR CPYS0
		INC *RSPTR
		INC *RSPTR
		JSR CPYA0S
		JSR PRINT
		DEC *RSPTR
		DEC *RSPTR
		JSR CPYS0
		INC R0
		INC R0
		JSR CPYA0S
		JSR ISNIL
		BEQ TAIL
		JSR CPYS0
		JSR CPYA0S
		JMP PNSXL

TAIL	LDA #RPAREN
		JSR OUT
		RTS

; PRINT SYMBOL

PNSYMB	LDY #0
		LDA (RPSTR),Y

; PRINT SYMBOL IN A

LPNSY	CLC
		ROR
		CMP #LTTRS
		BPL NSYMB
		ADC #AC
		JSR OUT
		RTS

NSYMB	CLC
		ADC #ZSDLTA
		JSR OUT
		RTS

; PRINT FUNCTION

PNFN	LDA #FDEF
		JSR OUT
		JMP PNPROC	

; PRINT MACRO

PNM 	LDA #MDEF
		JSR OUT

; PRINT PROCEDURE (COMMON TO FUNCTION AND MACRO)

PNPROC 	LDA #LBRKT
		JSR OUT
		JSR CPYS0
		LDY #

.END
