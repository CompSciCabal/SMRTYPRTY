# PFPL Chapter 39 - Process Calculi

##Definitions (39.1 & 39.2)
###Events

```
E = null      0     null
    or(E1;E2) E1+E2 choice
    que[a](P) ?a;P  query
    sig[a](P) !a;P  signal
```

###Processes

```
P = await(E)    $E synchronize
    stop        1  inert
    conc(P1;P2) P1xP2 composition
```

###Actions

```
A = que[a]  a?  query
    sig[a]  a!  signal
    sil     eps silent
```

Processes can interact through actions, using the dynamics rules.   It's a bit like action sequences take the place of stepping in earlier languages, so it is a generalization of a fixed step function for the dynamics of the language.

## Milners Teacup (39.1 & 39.2)
### Machine Process
The machine waits for 2p coins, if it gets one you get tea, if it gets 2 you get coffee

```
V = $(?2p;$(!tea;V + ?2p;$(!cof;V)))
```

Note that the signal and query `event;process` pairs bind tighter than the event `or` operator, `+`.  So the way to read this is that we are looking at an equation that can be stepped forward by pattern matching on different types of action signals to select which part of the equation to step forward.

### User Who Wants Coffee Process

```
U = $!2p;$!2p;$?cof;1
```

### Interacting
Processes interact when they are composed, i.e.

```
V x U
```

Then we can apply the dynamics judgements step by step, first by 39.4c we step `V`, and it steps once emitting a query action `2p?` by 39.4b, then again by 39.4c we can move on to  `U` and apply 39.4a to generate a signal action `2p!`.  Now 39.4d can be applied and the whole system pushed forward since these are complementary actions. Giving:

```
Vâ€™ = $(!tea;V + ?2p;$(!cof;V))
U' = $2p;$?cof;1
```

The next part is interesting, because it shows how these are interconnected and that there is no order to waiting for events connected by an `or`.  When I first read the `V'` I thought it meant emit a signal then do this other part, but it is not that.  Signals are not preemptively emitted to the world, instead what it is saying, is that, if your `!tea` event's corresponding action `tea!` matches against its complementary action `tea?`generated by a process it is composed with, then step this process forward to `V` and the other process to its new state.  

### Non-Determinism?
Since the stepping is like pattern matching, what if you give the same pattern twice, i.e.

```
B = $(?b;$!one + ?b;$!two);1
```

In the text he says that structural equivalence should prevent non-determinism, but how?

Rule 39.1f means we can switch the order of the events without changing anything, and then 39.4d says that the first event will always be evaluated first in the dynamics.  This seems to suggest that the above example is non-deterministic, or that somehow we are not allowed to write it.

## Replication (39.3)
Replication is an alternative to the equation presentation for processes, it seems closer to how people usually write programs so may be more natural.  We get a `*` operator that can replicate a process,

```
*P -> P x *P
```

The trick here is that without the replicated synchronization judgements given in this section, we have no way of knowing when to apply this process replicate rule.

The activator and server formulation of the teacup example (using `#` to start inline comments):

```
V0 = $(!v;1)  #Activate Server
V1 = *$(?v;V2)  #Server
V2 = $(?2p;$(!tea;V0 + ?2p;$(!cof;V0)))  #Server Implementation
```

So we get one server that can be composed with one client at a time, the `U` process from before.  I don't think this design can handle multiple clients at the same time though, so this would not be a great design for a server.

## Channels

Hmm, what is process alpha equality (39.11a)?  Can't seem to find the definition.

