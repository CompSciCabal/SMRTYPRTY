#lang racket

(require compatibility/defmacro)

(define-macro (send! to pin message)
  `(thread-send ,to (cons ,pin ,message)))

(define-macro (make-part parent . body)
  (let ((fn (gensym))
	(pr (gensym)))
    `(letrec ((,pr ,parent)
	      (out! (lambda (pin msg)
		      (let ((m (list (current-thread) pin msg)))
			(if ,pr
			    (thread-send ,pr m)
			    (displayln m)))))
	      (,fn (lambda ()
		     (match (thread-receive)
		       [(cons pin msg) ,@body]
		       [junk (out! 'error "Malformed message")])
		     (,fn))))
       (thread ,fn))))

(define-macro (make-proxy parent parts . system-map)
  (define (convert-item itm)
    `(list ,(car itm) ',(cadr itm)))
  (define (convert-line conn-line)
    `(cons ,(convert-item (car conn-line)) (list ,@(map convert-item (cddr conn-line)))))
  (define (part->f-binding part-pair)
    `(,(car part-pair) #f))
  (define (part->set-form part-pair)
    `(set! ,(car part-pair) ,(cadr part-pair)))
  (let ((pt (gensym))
	(launch (gensym))
	(fn (gensym))
	(setup (gensym)))
    `(let ((,pt ,parent)
	   (self #f)
	   (connections #f))
       (let ((,launch
	      (lambda (msg)
		(lambda (part/pin)
		  (cond ((and ,pt (eq? (first part/pin) self))
			 (thread-send ,pt (list (current-thread) (second part/pin) msg)))
			((not (eq? (first part/pin) self))
			 (thread-send (first part/pin) (cons (second part/pin) msg))))))))
	 (let ,(map part->f-binding parts)
	   (letrec ((,fn (lambda ()
			   (match (thread-receive)
			     [(list src pin msg)
			      (let ((targets (assoc (list src pin) connections)))
				(map (,launch msg) (if targets (cdr targets) '())))]
			     [(cons pin msg)
			      (let ((targets (assoc (list self pin) connections)))
				(map (,launch msg) (if targets (cdr targets) '())))])
			   (,fn)))
		    (,setup (lambda ()
			      (set! self (current-thread))
			      ,@(map part->set-form parts)
			      (set! connections (list ,@(map convert-line system-map)))
			      (,fn))))
	     (thread ,setup)))))))

(define (make-counter parent)
  (let ((count 0))
    (make-part parent
	       (set! count (+ 1 count))
	       (out! 'out count))))

(define (make-greeter parent template)
  (make-part parent (out! 'out (format template msg))))

(define test 
  (make-proxy #f
   ((pr (make-part self (displayln (format "Printing: ~a" msg))))
    (ct (make-counter self))
    (greet (make-greeter self "Hello there, ~a!")))
   ((self in) -> (ct in) (pr in) (greet in))
   ((ct out) -> (pr in))
   ((greet out) -> (pr in))))

(define (load-test num)
  (unless (zero? num)
    (send! test 'in (format "Name-~a" num))
    (load-test (- num 1))))

;; (enter! "fbp.rkt")
(send! test 'in "Inaimathi")
(send! test 'in "Garamond")
(send! test 'in "Corsiva")
